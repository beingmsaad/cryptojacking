"/*! jQuery Validation Plugin - v1.15.0 - 2/24/2016\n * http://jqueryvalidation.org/\n * Copyright (c) 2016 JÃ¶rn Zaefferer; Licensed MIT */\n!function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):\"object\"==typeof module&&module.exports?module.exports=a(require(\"jquery\")):a(jQuery)}(function(a){a.extend(a.fn,{validate:function(b){if(!this.length)return void(b&&b.debug&&window.console&&console.warn(\"Nothing selected, can't validate, returning nothing.\"));var c=a.data(this[0],\"validator\");return c?c:(this.attr(\"novalidate\",\"novalidate\"),c=new a.validator(b,this[0]),a.data(this[0],\"validator\",c),c.settings.onsubmit&&(this.on(\"click.validate\",\":submit\",function(b){c.settings.submitHandler&&(c.submitButton=b.target),a(this).hasClass(\"cancel\")&&(c.cancelSubmit=!0),void 0!==a(this).attr(\"formnovalidate\")&&(c.cancelSubmit=!0)}),this.on(\"submit.validate\",function(b){function d(){var d,e;return c.settings.submitHandler?(c.submitButton&&(d=a(\"<input type='hidden'/>\").attr(\"name\",c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)),e=c.settings.submitHandler.call(c,c.currentForm,b),c.submitButton&&d.remove(),void 0!==e?e:!1):!0}return c.settings.debug&&b.preventDefault(),c.cancelSubmit?(c.cancelSubmit=!1,d()):c.form()?c.pendingRequest?(c.formSubmitted=!0,!1):d():(c.focusInvalid(),!1)})),c)},valid:function(){var b,c,d;return a(this[0]).is(\"form\")?b=this.validate().form():(d=[],b=!0,c=a(this[0].form).validate(),this.each(function(){b=c.element(this)&&b,b||(d=d.concat(c.errorList))}),c.errorList=d),b},rules:function(b,c){if(this.length){var d,e,f,g,h,i,j=this[0];if(b)switch(d=a.data(j.form,\"validator\").settings,e=d.rules,f=a.validator.staticRules(j),b){case\"add\":a.extend(f,a.validator.normalizeRule(c)),delete f.messages,e[j.name]=f,c.messages&&(d.messages[j.name]=a.extend(d.messages[j.name],c.messages));break;case\"remove\":return c?(i={},a.each(c.split(/\\s/),function(b,c){i[c]=f[c],delete f[c],\"required\"===c&&a(j).removeAttr(\"aria-required\")}),i):(delete e[j.name],f)}return g=a.validator.normalizeRules(a.extend({},a.validator.classRules(j),a.validator.attributeRules(j),a.validator.dataRules(j),a.validator.staticRules(j)),j),g.required&&(h=g.required,delete g.required,g=a.extend({required:h},g),a(j).attr(\"aria-required\",\"true\")),g.remote&&(h=g.remote,delete g.remote,g=a.extend(g,{remote:h})),g}}}),a.extend(a.expr[\":\"],{blank:function(b){return!a.trim(\"\"+a(b).val())},filled:function(b){var c=a(b).val();return null!==c&&!!a.trim(\"\"+c)},unchecked:function(b){return!a(b).prop(\"checked\")}}),a.validator=function(b,c){this.settings=a.extend(!0,{},a.validator.defaults,b),this.currentForm=c,this.init()},a.validator.format=function(b,c){return 1===arguments.length?function(){var c=a.makeArray(arguments);return c.unshift(b),a.validator.format.apply(this,c)}:void 0===c?b:(arguments.length>2&&c.constructor!==Array&&(c=a.makeArray(arguments).slice(1)),c.constructor!==Array&&(c=[c]),a.each(c,function(a,c){b=b.replace(new RegExp(\"\\\\{\"+a+\"\\\\}\",\"g\"),function(){return c})}),b)},a.extend(a.validator,{defaults:{messages:{},groups:{},rules:{},errorClass:\"error\",pendingClass:\"pending\",validClass:\"valid\",errorElement:\"label\",focusCleanup:!1,focusInvalid:!0,errorContainer:a([]),errorLabelContainer:a([]),onsubmit:!0,ignore:\":hidden\",ignoreTitle:!1,onfocusin:function(a){this.lastActive=a,this.settings.focusCleanup&&(this.settings.unhighlight&&this.settings.unhighlight.call(this,a,this.settings.errorClass,this.settings.validClass),this.hideThese(this.errorsFor(a)))},onfocusout:function(a){this.checkable(a)||!(a.name in this.submitted)&&this.optional(a)||this.element(a)},onkeyup:function(b,c){var d=[16,17,18,20,35,36,37,38,39,40,45,144,225];9===c.which&&\"\"===this.elementValue(b)||-1!==a.inArray(c.keyCode,d)||(b.name in this.submitted||b.name in this.invalid)&&this.element(b)},onclick:function(a){a.name in this.submitted?this.element(a):a.parentNode.name in this.submitted&&this.element(a.parentNode)},highlight:function(b,c,d){\"radio\"===b.type?this.findByName(b.name).addClass(c).removeClass(d):a(b).addClass(c).removeClass(d)},unhighlight:function(b,c,d){\"radio\"===b.type?this.findByName(b.name).removeClass(c).addClass(d):a(b).removeClass(c).addClass(d)}},setDefaults:function(b){a.extend(a.validator.defaults,b)},messages:{required:\"This field is required.\",remote:\"Please fix this field.\",email:\"Please enter a valid email address.\",url:\"Please enter a valid URL.\",date:\"Please enter a valid date.\",dateISO:\"Please enter a valid date ( ISO ).\",number:\"Please enter a valid number.\",digits:\"Please enter only digits.\",equalTo:\"Please enter the same value again.\",maxlength:a.validator.format(\"Please enter no more than {0} characters.\"),minlength:a.validator.format(\"Please enter at least {0} characters.\"),rangelength:a.validator.format(\"Please enter a value between {0} and {1} characters long.\"),range:a.validator.format(\"Please enter a value between {0} and {1}.\"),max:a.validator.format(\"Please enter a value less than or equal to {0}.\"),min:a.validator.format(\"Please enter a value greater than or equal to {0}.\"),step:a.validator.format(\"Please enter a multiple of {0}.\")},autoCreateRanges:!1,prototype:{init:function(){function b(b){var c=a.data(this.form,\"validator\"),d=\"on\"+b.type.replace(/^validate/,\"\"),e=c.settings;e[d]&&!a(this).is(e.ignore)&&e[d].call(c,this,b)}this.labelContainer=a(this.settings.errorLabelContainer),this.errorContext=this.labelContainer.length&&this.labelContainer||a(this.currentForm),this.containers=a(this.settings.errorContainer).add(this.settings.errorLabelContainer),this.submitted={},this.valueCache={},this.pendingRequest=0,this.pending={},this.invalid={},this.reset();var c,d=this.groups={};a.each(this.settings.groups,function(b,c){\"string\"==typeof c&&(c=c.split(/\\s/)),a.each(c,function(a,c){d[c]=b})}),c=this.settings.rules,a.each(c,function(b,d){c[b]=a.validator.normalizeRule(d)}),a(this.currentForm).on(\"focusin.validate focusout.validate keyup.validate\",\":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable]\",b).on(\"click.validate\",\"select, option, [type='radio'], [type='checkbox']\",b),this.settings.invalidHandler&&a(this.currentForm).on(\"invalid-form.validate\",this.settings.invalidHandler),a(this.currentForm).find(\"[required], [data-rule-required], .required\").attr(\"aria-required\",\"true\")},form:function(){return this.checkForm(),a.extend(this.submitted,this.errorMap),this.invalid=a.extend({},this.errorMap),this.valid()||a(this.currentForm).triggerHandler(\"invalid-form\",[this]),this.showErrors(),this.valid()},checkForm:function(){this.prepareForm();for(var a=0,b=this.currentElements=this.elements();b[a];a++)this.check(b[a]);return this.valid()},element:function(b){var c,d,e=this.clean(b),f=this.validationTargetFor(e),g=this,h=!0;return void 0===f?delete this.invalid[e.name]:(this.prepareElement(f),this.currentElements=a(f),d=this.groups[f.name],d&&a.each(this.groups,function(a,b){b===d&&a!==f.name&&(e=g.validationTargetFor(g.clean(g.findByName(a))),e&&e.name in g.invalid&&(g.currentElements.push(e),h=h&&g.check(e)))}),c=this.check(f)!==!1,h=h&&c,c?this.invalid[f.name]=!1:this.invalid[f.name]=!0,this.numberOfInvalids()||(this.toHide=this.toHide.add(this.containers)),this.showErrors(),a(b).attr(\"aria-invalid\",!c)),h},showErrors:function(b){if(b){var c=this;a.extend(this.errorMap,b),this.errorList=a.map(this.errorMap,function(a,b){return{message:a,element:c.findByName(b)[0]}}),this.successList=a.grep(this.successList,function(a){return!(a.name in b)})}this.settings.showErrors?this.settings.showErrors.call(this,this.errorMap,this.errorList):this.defaultShowErrors()},resetForm:function(){a.fn.resetForm&&a(this.currentForm).resetForm(),this.invalid={},this.submitted={},this.prepareForm(),this.hideErrors();var b=this.elements().removeData(\"previousValue\").removeAttr(\"aria-invalid\");this.resetElements(b)},resetElements:function(a){var b;if(this.settings.unhighlight)for(b=0;a[b];b++)this.settings.unhighlight.call(this,a[b],this.settings.errorClass,\"\"),this.findByName(a[b].name).removeClass(this.settings.validClass);else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass)},numberOfInvalids:function(){return this.objectLength(this.invalid)},objectLength:function(a){var b,c=0;for(b in a)a[b]&&c++;return c},hideErrors:function(){this.hideThese(this.toHide)},hideThese:function(a){a.not(this.containers).text(\"\"),this.addWrapper(a).hide()},valid:function(){return 0===this.size()},size:function(){return this.errorList.length},focusInvalid:function(){if(this.settings.focusInvalid)try{a(this.findLastActive()||this.errorList.length&&this.errorList[0].element||[]).filter(\":visible\").focus().trigger(\"focusin\")}catch(b){}},findLastActive:function(){var b=this.lastActive;return b&&1===a.grep(this.errorList,function(a){return a.element.name===b.name}).length&&b},elements:function(){var b=this,c={};return a(this.currentForm).find(\"input, select, textarea, [contenteditable]\").not(\":submit, :reset, :image, :disabled\").not(this.settings.ignore).filter(function(){var d=this.name||a(this).attr(\"name\");return!d&&b.settings.debug&&window.console&&console.error(\"%o has no name assigned\",this),this.hasAttribute(\"contenteditable\")&&(this.form=a(this).closest(\"form\")[0]),d in c||!b.objectLength(a(this).rules())?!1:(c[d]=!0,!0)})},clean:function(b){return a(b)[0]},errors:function(){var b=this.settings.errorClass.split(\" \").join(\".\");return a(this.settings.errorElement+\".\"+b,this.errorContext)},resetInternals:function(){this.successList=[],this.errorList=[],this.errorMap={},this.toShow=a([]),this.toHide=a([])},reset:function(){this.resetInternals(),this.currentElements=a([])},prepareForm:function(){this.reset(),this.toHide=this.errors().add(this.containers)},prepareElement:function(a){this.reset(),this.toHide=this.errorsFor(a)},elementValue:function(b){var c,d,e=a(b),f=b.type;return\"radio\"===f||\"checkbox\"===f?this.findByName(b.name).filter(\":checked\").val():\"number\"===f&&\"undefined\"!=typeof b.validity?b.validity.badInput?\"NaN\":e.val():(c=b.hasAttribute(\"contenteditable\")?e.text():e.val(),\"file\"===f?\"C:\\\\fakepath\\\\\"===c.substr(0,12)?c.substr(12):(d=c.lastIndexOf(\"/\"),d>=0?c.substr(d+1):(d=c.lastIndexOf(\"\\\\\"),d>=0?c.substr(d+1):c)):\"string\"==typeof c?c.replace(/\\r/g,\"\"):c)},check:function(b){b=this.validationTargetFor(this.clean(b));var c,d,e,f=a(b).rules(),g=a.map(f,function(a,b){return b}).length,h=!1,i=this.elementValue(b);if(\"function\"==typeof f.normalizer){if(i=f.normalizer.call(b,i),\"string\"!=typeof i)throw new TypeError(\"The normalizer should return a string value.\");delete f.normalizer}for(d in f){e={method:d,parameters:f[d]};try{if(c=a.validator.methods[d].call(this,i,b,e.parameters),\"dependency-mismatch\"===c&&1===g){h=!0;continue}if(h=!1,\"pending\"===c)return void(this.toHide=this.toHide.not(this.errorsFor(b)));if(!c)return this.formatAndAdd(b,e),!1}catch(j){throw this.settings.debug&&window.console&&console.log(\"Exception occurred when checking element \"+b.id+\", check the '\"+e.method+\"' method.\",j),j instanceof TypeError&&(j.message+=\".  Exception occurred when checking element \"+b.id+\", check the '\"+e.method+\"' method.\"),j}}if(!h)return this.objectLength(f)&&this.successList.push(b),!0},customDataMessage:function(b,c){return a(b).data(\"msg\"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase())||a(b).data(\"msg\")},customMessage:function(a,b){var c=this.settings.messages[a];return c&&(c.constructor===String?c:c[b])},findDefined:function(){for(var a=0;a<arguments.length;a++)if(void 0!==arguments[a])return arguments[a]},defaultMessage:function(b,c){var d=this.findDefined(this.customMessage(b.name,c.method),this.customDataMessage(b,c.method),!this.settings.ignoreTitle&&b.title||void 0,a.validator.messages[c.method],\"<strong>Warning: No message defined for \"+b.name+\"</strong>\"),e=/\\$?\\{(\\d+)\\}/g;return\"function\"==typeof d?d=d.call(this,c.parameters,b):e.test(d)&&(d=a.validator.format(d.replace(e,\"{$1}\"),c.parameters)),d},formatAndAdd:function(a,b){var c=this.defaultMessage(a,b);this.errorList.push({message:c,element:a,method:b.method}),this.errorMap[a.name]=c,this.submitted[a.name]=c},addWrapper:function(a){return this.settings.wrapper&&(a=a.add(a.parent(this.settings.wrapper))),a},defaultShowErrors:function(){var a,b,c;for(a=0;this.errorList[a];a++)c=this.errorList[a],this.settings.highlight&&this.settings.highlight.call(this,c.element,this.settings.errorClass,this.settings.validClass),this.showLabel(c.element,c.message);if(this.errorList.length&&(this.toShow=this.toShow.add(this.containers)),this.settings.success)for(a=0;this.successList[a];a++)this.showLabel(this.successList[a]);if(this.settings.unhighlight)for(a=0,b=this.validElements();b[a];a++)this.settings.unhighlight.call(this,b[a],this.settings.errorClass,this.settings.validClass);this.toHide=this.toHide.not(this.toShow),this.hideErrors(),this.addWrapper(this.toShow).show()},validElements:function(){return this.currentElements.not(this.invalidElements())},invalidElements:function(){return a(this.errorList).map(function(){return this.element})},showLabel:function(b,c){var d,e,f,g,h=this.errorsFor(b),i=this.idOrName(b),j=a(b).attr(\"aria-describedby\");h.length?(h.removeClass(this.settings.validClass).addClass(this.settings.errorClass),h.html(c)):(h=a(\"<\"+this.settings.errorElement+\">\").attr(\"id\",i+\"-error\").addClass(this.settings.errorClass).html(c||\"\"),d=h,this.settings.wrapper&&(d=h.hide().show().wrap(\"<\"+this.settings.wrapper+\"/>\").parent()),this.labelContainer.length?this.labelContainer.append(d):this.settings.errorPlacement?this.settings.errorPlacement(d,a(b)):d.insertAfter(b),h.is(\"label\")?h.attr(\"for\",i):0===h.parents(\"label[for='\"+this.escapeCssMeta(i)+\"']\").length&&(f=h.attr(\"id\"),j?j.match(new RegExp(\"\\\\b\"+this.escapeCssMeta(f)+\"\\\\b\"))||(j+=\" \"+f):j=f,a(b).attr(\"aria-describedby\",j),e=this.groups[b.name],e&&(g=this,a.each(g.groups,function(b,c){c===e&&a(\"[name='\"+g.escapeCssMeta(b)+\"']\",g.currentForm).attr(\"aria-describedby\",h.attr(\"id\"))})))),!c&&this.settings.success&&(h.text(\"\"),\"string\"==typeof this.settings.success?h.addClass(this.settings.success):this.settings.success(h,b)),this.toShow=this.toShow.add(h)},errorsFor:function(b){var c=this.escapeCssMeta(this.idOrName(b)),d=a(b).attr(\"aria-describedby\"),e=\"label[for='\"+c+\"'], label[for='\"+c+\"'] *\";return d&&(e=e+\", #\"+this.escapeCssMeta(d).replace(/\\s+/g,\", #\")),this.errors().filter(e)},escapeCssMeta:function(a){return a.replace(/([\\\\!\"#$%&'()*+,./:;<=>?@\\[\\]^`{|}~])/g,\"\\\\$1\")},idOrName:function(a){return this.groups[a.name]||(this.checkable(a)?a.name:a.id||a.name)},validationTargetFor:function(b){return this.checkable(b)&&(b=this.findByName(b.name)),a(b).not(this.settings.ignore)[0]},checkable:function(a){return/radio|checkbox/i.test(a.type)},findByName:function(b){return a(this.currentForm).find(\"[name='\"+this.escapeCssMeta(b)+\"']\")},getLength:function(b,c){switch(c.nodeName.toLowerCase()){case\"select\":return a(\"option:selected\",c).length;case\"input\":if(this.checkable(c))return this.findByName(c.name).filter(\":checked\").length}return b.length},depend:function(a,b){return this.dependTypes[typeof a]?this.dependTypes[typeof a](a,b):!0},dependTypes:{\"boolean\":function(a){return a},string:function(b,c){return!!a(b,c.form).length},\"function\":function(a,b){return a(b)}},optional:function(b){var c=this.elementValue(b);return!a.validator.methods.required.call(this,c,b)&&\"dependency-mismatch\"},startRequest:function(b){this.pending[b.name]||(this.pendingRequest++,a(b).addClass(this.settings.pendingClass),this.pending[b.name]=!0)},stopRequest:function(b,c){this.pendingRequest--,this.pendingRequest<0&&(this.pendingRequest=0),delete this.pending[b.name],a(b).removeClass(this.settings.pendingClass),c&&0===this.pendingRequest&&this.formSubmitted&&this.form()?(a(this.currentForm).submit(),this.formSubmitted=!1):!c&&0===this.pendingRequest&&this.formSubmitted&&(a(this.currentForm).triggerHandler(\"invalid-form\",[this]),this.formSubmitted=!1)},previousValue:function(b,c){return a.data(b,\"previousValue\")||a.data(b,\"previousValue\",{old:null,valid:!0,message:this.defaultMessage(b,{method:c})})},destroy:function(){this.resetForm(),a(this.currentForm).off(\".validate\").removeData(\"validator\").find(\".validate-equalTo-blur\").off(\".validate-equalTo\").removeClass(\"validate-equalTo-blur\")}},classRuleSettings:{required:{required:!0},email:{email:!0},url:{url:!0},date:{date:!0},dateISO:{dateISO:!0},number:{number:!0},digits:{digits:!0},creditcard:{creditcard:!0}},addClassRules:function(b,c){b.constructor===String?this.classRuleSettings[b]=c:a.extend(this.classRuleSettings,b)},classRules:function(b){var c={},d=a(b).attr(\"class\");return d&&a.each(d.split(\" \"),function(){this in a.validator.classRuleSettings&&a.extend(c,a.validator.classRuleSettings[this])}),c},normalizeAttributeRule:function(a,b,c,d){/min|max|step/.test(c)&&(null===b||/number|range|text/.test(b))&&(d=Number(d),isNaN(d)&&(d=void 0)),d||0===d?a[c]=d:b===c&&\"range\"!==b&&(a[c]=!0)},attributeRules:function(b){var c,d,e={},f=a(b),g=b.getAttribute(\"type\");for(c in a.validator.methods)\"required\"===c?(d=b.getAttribute(c),\"\"===d&&(d=!0),d=!!d):d=f.attr(c),this.normalizeAttributeRule(e,g,c,d);return e.maxlength&&/-1|2147483647|524288/.test(e.maxlength)&&delete e.maxlength,e},dataRules:function(b){var c,d,e={},f=a(b),g=b.getAttribute(\"type\");for(c in a.validator.methods)d=f.data(\"rule\"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase()),this.normalizeAttributeRule(e,g,c,d);return e},staticRules:function(b){var c={},d=a.data(b.form,\"validator\");return d.settings.rules&&(c=a.validator.normalizeRule(d.settings.rules[b.name])||{}),c},normalizeRules:function(b,c){return a.each(b,function(d,e){if(e===!1)return void delete b[d];if(e.param||e.depends){var f=!0;switch(typeof e.depends){case\"string\":f=!!a(e.depends,c.form).length;break;case\"function\":f=e.depends.call(c,c)}f?b[d]=void 0!==e.param?e.param:!0:(a.data(c.form,\"validator\").resetElements(a(c)),delete b[d])}}),a.each(b,function(d,e){b[d]=a.isFunction(e)&&\"normalizer\"!==d?e(c):e}),a.each([\"minlength\",\"maxlength\"],function(){b[this]&&(b[this]=Number(b[this]))}),a.each([\"rangelength\",\"range\"],function(){var c;b[this]&&(a.isArray(b[this])?b[this]=[Number(b[this][0]),Number(b[this][1])]:\"string\"==typeof b[this]&&(c=b[this].replace(/[\\[\\]]/g,\"\").split(/[\\s,]+/),b[this]=[Number(c[0]),Number(c[1])]))}),a.validator.autoCreateRanges&&(null!=b.min&&null!=b.max&&(b.range=[b.min,b.max],delete b.min,delete b.max),null!=b.minlength&&null!=b.maxlength&&(b.rangelength=[b.minlength,b.maxlength],delete b.minlength,delete b.maxlength)),b},normalizeRule:function(b){if(\"string\"==typeof b){var c={};a.each(b.split(/\\s/),function(){c[this]=!0}),b=c}return b},addMethod:function(b,c,d){a.validator.methods[b]=c,a.validator.messages[b]=void 0!==d?d:a.validator.messages[b],c.length<3&&a.validator.addClassRules(b,a.validator.normalizeRule(b))},methods:{required:function(b,c,d){if(!this.depend(d,c))return\"dependency-mismatch\";if(\"select\"===c.nodeName.toLowerCase()){var e=a(c).val();return e&&e.length>0}return this.checkable(c)?this.getLength(b,c)>0:b.length>0},email:function(a,b){return this.optional(b)||/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a)},url:function(a,b){return this.optional(b)||/^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})).?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(a)},date:function(a,b){return this.optional(b)||!/Invalid|NaN/.test(new Date(a).toString())},dateISO:function(a,b){return this.optional(b)||/^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test(a)},number:function(a,b){return this.optional(b)||/^(?:-?\\d+|-?\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test(a)},digits:function(a,b){return this.optional(b)||/^\\d+$/.test(a)},minlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e>=d},maxlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||d>=e},rangelength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e>=d[0]&&e<=d[1]},min:function(a,b,c){return this.optional(b)||a>=c},max:function(a,b,c){return this.optional(b)||c>=a},range:function(a,b,c){return this.optional(b)||a>=c[0]&&a<=c[1]},step:function(b,c,d){var e=a(c).attr(\"type\"),f=\"Step attribute on input type \"+e+\" is not supported.\",g=[\"text\",\"number\",\"range\"],h=new RegExp(\"\\\\b\"+e+\"\\\\b\"),i=e&&!h.test(g.join());if(i)throw new Error(f);return this.optional(c)||b%d===0},equalTo:function(b,c,d){var e=a(d);return this.settings.onfocusout&&e.not(\".validate-equalTo-blur\").length&&e.addClass(\"validate-equalTo-blur\").on(\"blur.validate-equalTo\",function(){a(c).valid()}),b===e.val()},remote:function(b,c,d,e){if(this.optional(c))return\"dependency-mismatch\";e=\"string\"==typeof e&&e||\"remote\";var f,g,h,i=this.previousValue(c,e);return this.settings.messages[c.name]||(this.settings.messages[c.name]={}),i.originalMessage=i.originalMessage||this.settings.messages[c.name][e],this.settings.messages[c.name][e]=i.message,d=\"string\"==typeof d&&{url:d}||d,h=a.param(a.extend({data:b},d.data)),i.old===h?i.valid:(i.old=h,f=this,this.startRequest(c),g={},g[c.name]=b,a.ajax(a.extend(!0,{mode:\"abort\",port:\"validate\"+c.name,dataType:\"json\",data:g,context:f.currentForm,success:function(a){var d,g,h,j=a===!0||\"true\"===a;f.settings.messages[c.name][e]=i.originalMessage,j?(h=f.formSubmitted,f.resetInternals(),f.toHide=f.errorsFor(c),f.formSubmitted=h,f.successList.push(c),f.invalid[c.name]=!1,f.showErrors()):(d={},g=a||f.defaultMessage(c,{method:e,parameters:b}),d[c.name]=i.message=g,f.invalid[c.name]=!0,f.showErrors(d)),i.valid=j,f.stopRequest(c,j)}},d)),\"pending\")}}});var b,c={};a.ajaxPrefilter?a.ajaxPrefilter(function(a,b,d){var e=a.port;\"abort\"===a.mode&&(c[e]&&c[e].abort(),c[e]=d)}):(b=a.ajax,a.ajax=function(d){var e=(\"mode\"in d?d:a.ajaxSettings).mode,f=(\"port\"in d?d:a.ajaxSettings).port;return\"abort\"===e?(c[f]&&c[f].abort(),c[f]=b.apply(this,arguments),c[f]):b.apply(this,arguments)})});"
"/*!\n * jQuery Form Plugin\n * version: 3.51.0-2014.06.20\n * Requires jQuery v1.5 or later\n * Copyright (c) 2014 M. Alsup\n * Examples and documentation at: http://malsup.com/jquery/form/\n * Project repository: https://github.com/malsup/form\n * Dual licensed under the MIT and GPL licenses.\n * https://github.com/malsup/form#copyright-and-license\n */\n/*global ActiveXObject */\n\n// AMD support\n(function (factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        // using AMD; register as anon module\n        define(['jquery'], factory);\n    } else {\n        // no AMD; invoke directly\n        factory( (typeof(jQuery) != 'undefined') ? jQuery : window.Zepto );\n    }\n}\n\n(function($) {\n\"use strict\";\n\n/*\n    Usage Note:\n    -----------\n    Do not use both ajaxSubmit and ajaxForm on the same form.  These\n    functions are mutually exclusive.  Use ajaxSubmit if you want\n    to bind your own submit handler to the form.  For example,\n\n    $(document).ready(function() {\n        $('#myForm').on('submit', function(e) {\n            e.preventDefault(); // <-- important\n            $(this).ajaxSubmit({\n                target: '#output'\n            });\n        });\n    });\n\n    Use ajaxForm when you want the plugin to manage all the event binding\n    for you.  For example,\n\n    $(document).ready(function() {\n        $('#myForm').ajaxForm({\n            target: '#output'\n        });\n    });\n\n    You can also use ajaxForm with delegation (requires jQuery v1.7+), so the\n    form does not have to exist when you invoke ajaxForm:\n\n    $('#myForm').ajaxForm({\n        delegation: true,\n        target: '#output'\n    });\n\n    When using ajaxForm, the ajaxSubmit function will be invoked for you\n    at the appropriate time.\n*/\n\n/**\n * Feature detection\n */\nvar feature = {};\nfeature.fileapi = $(\"<input type='file'/>\").get(0).files !== undefined;\nfeature.formdata = window.FormData !== undefined;\n\nvar hasProp = !!$.fn.prop;\n\n// attr2 uses prop when it can but checks the return type for\n// an expected string.  this accounts for the case where a form \n// contains inputs with names like \"action\" or \"method\"; in those\n// cases \"prop\" returns the element\n$.fn.attr2 = function() {\n    if ( ! hasProp ) {\n        return this.attr.apply(this, arguments);\n    }\n    var val = this.prop.apply(this, arguments);\n    if ( ( val && val.jquery ) || typeof val === 'string' ) {\n        return val;\n    }\n    return this.attr.apply(this, arguments);\n};\n\n/**\n * ajaxSubmit() provides a mechanism for immediately submitting\n * an HTML form using AJAX.\n */\n$.fn.ajaxSubmit = function(options) {\n    /*jshint scripturl:true */\n\n    // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)\n    if (!this.length) {\n        log('ajaxSubmit: skipping submit process - no element selected');\n        return this;\n    }\n\n    var method, action, url, $form = this;\n\n    if (typeof options == 'function') {\n        options = { success: options };\n    }\n    else if ( options === undefined ) {\n        options = {};\n    }\n\n    method = options.type || this.attr2('method');\n    action = options.url  || this.attr2('action');\n\n    url = (typeof action === 'string') ? $.trim(action) : '';\n    url = url || window.location.href || '';\n    if (url) {\n        // clean url (don't include hash vaue)\n        url = (url.match(/^([^#]+)/)||[])[1];\n    }\n\n    options = $.extend(true, {\n        url:  url,\n        success: $.ajaxSettings.success,\n        type: method || $.ajaxSettings.type,\n        iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'\n    }, options);\n\n    // hook for manipulating the form data before it is extracted;\n    // convenient for use with rich editors like tinyMCE or FCKEditor\n    var veto = {};\n    this.trigger('form-pre-serialize', [this, options, veto]);\n    if (veto.veto) {\n        log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');\n        return this;\n    }\n\n    // provide opportunity to alter form data before it is serialized\n    if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {\n        log('ajaxSubmit: submit aborted via beforeSerialize callback');\n        return this;\n    }\n\n    var traditional = options.traditional;\n    if ( traditional === undefined ) {\n        traditional = $.ajaxSettings.traditional;\n    }\n\n    var elements = [];\n    var qx, a = this.formToArray(options.semantic, elements);\n    if (options.data) {\n        options.extraData = options.data;\n        qx = $.param(options.data, traditional);\n    }\n\n    // give pre-submit callback an opportunity to abort the submit\n    if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {\n        log('ajaxSubmit: submit aborted via beforeSubmit callback');\n        return this;\n    }\n\n    // fire vetoable 'validate' event\n    this.trigger('form-submit-validate', [a, this, options, veto]);\n    if (veto.veto) {\n        log('ajaxSubmit: submit vetoed via form-submit-validate trigger');\n        return this;\n    }\n\n    var q = $.param(a, traditional);\n    if (qx) {\n        q = ( q ? (q + '&' + qx) : qx );\n    }\n    if (options.type.toUpperCase() == 'GET') {\n        options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;\n        options.data = null;  // data is null for 'get'\n    }\n    else {\n        options.data = q; // data is the query string for 'post'\n    }\n\n    var callbacks = [];\n    if (options.resetForm) {\n        callbacks.push(function() { $form.resetForm(); });\n    }\n    if (options.clearForm) {\n        callbacks.push(function() { $form.clearForm(options.includeHidden); });\n    }\n\n    // perform a load on the target only if dataType is not provided\n    if (!options.dataType && options.target) {\n        var oldSuccess = options.success || function(){};\n        callbacks.push(function(data) {\n            var fn = options.replaceTarget ? 'replaceWith' : 'html';\n            $(options.target)[fn](data).each(oldSuccess, arguments);\n        });\n    }\n    else if (options.success) {\n        callbacks.push(options.success);\n    }\n\n    options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg\n        var context = options.context || this ;    // jQuery 1.4+ supports scope context\n        for (var i=0, max=callbacks.length; i < max; i++) {\n            callbacks[i].apply(context, [data, status, xhr || $form, $form]);\n        }\n    };\n\n    if (options.error) {\n        var oldError = options.error;\n        options.error = function(xhr, status, error) {\n            var context = options.context || this;\n            oldError.apply(context, [xhr, status, error, $form]);\n        };\n    }\n\n     if (options.complete) {\n        var oldComplete = options.complete;\n        options.complete = function(xhr, status) {\n            var context = options.context || this;\n            oldComplete.apply(context, [xhr, status, $form]);\n        };\n    }\n\n    // are there files to upload?\n\n    // [value] (issue #113), also see comment:\n    // https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219\n    var fileInputs = $('input[type=file]:enabled', this).filter(function() { return $(this).val() !== ''; });\n\n    var hasFileInputs = fileInputs.length > 0;\n    var mp = 'multipart/form-data';\n    var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);\n\n    var fileAPI = feature.fileapi && feature.formdata;\n    log(\"fileAPI :\" + fileAPI);\n    var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;\n\n    var jqxhr;\n\n    // options.iframe allows user to force iframe mode\n    // 06-NOV-09: now defaulting to iframe mode if file input is detected\n    if (options.iframe !== false && (options.iframe || shouldUseFrame)) {\n        // hack to fix Safari hang (thanks to Tim Molendijk for this)\n        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d\n        if (options.closeKeepAlive) {\n            $.get(options.closeKeepAlive, function() {\n                jqxhr = fileUploadIframe(a);\n            });\n        }\n        else {\n            jqxhr = fileUploadIframe(a);\n        }\n    }\n    else if ((hasFileInputs || multipart) && fileAPI) {\n        jqxhr = fileUploadXhr(a);\n    }\n    else {\n        jqxhr = $.ajax(options);\n    }\n\n    $form.removeData('jqxhr').data('jqxhr', jqxhr);\n\n    // clear element array\n    for (var k=0; k < elements.length; k++) {\n        elements[k] = null;\n    }\n\n    // fire 'notify' event\n    this.trigger('form-submit-notify', [this, options]);\n    return this;\n\n    // utility fn for deep serialization\n    function deepSerialize(extraData){\n        var serialized = $.param(extraData, options.traditional).split('&');\n        var len = serialized.length;\n        var result = [];\n        var i, part;\n        for (i=0; i < len; i++) {\n            // #252; undo param space replacement\n            serialized[i] = serialized[i].replace(/\\+/g,' ');\n            part = serialized[i].split('=');\n            // #278; use array instead of object storage, favoring array serializations\n            result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);\n        }\n        return result;\n    }\n\n     // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)\n    function fileUploadXhr(a) {\n        var formdata = new FormData();\n\n        for (var i=0; i < a.length; i++) {\n            formdata.append(a[i].name, a[i].value);\n        }\n\n        if (options.extraData) {\n            var serializedData = deepSerialize(options.extraData);\n            for (i=0; i < serializedData.length; i++) {\n                if (serializedData[i]) {\n                    formdata.append(serializedData[i][0], serializedData[i][1]);\n                }\n            }\n        }\n\n        options.data = null;\n\n        var s = $.extend(true, {}, $.ajaxSettings, options, {\n            contentType: false,\n            processData: false,\n            cache: false,\n            type: method || 'POST'\n        });\n\n        if (options.uploadProgress) {\n            // workaround because jqXHR does not expose upload property\n            s.xhr = function() {\n                var xhr = $.ajaxSettings.xhr();\n                if (xhr.upload) {\n                    xhr.upload.addEventListener('progress', function(event) {\n                        var percent = 0;\n                        var position = event.loaded || event.position; /*event.position is deprecated*/\n                        var total = event.total;\n                        if (event.lengthComputable) {\n                            percent = Math.ceil(position / total * 100);\n                        }\n                        options.uploadProgress(event, position, total, percent);\n                    }, false);\n                }\n                return xhr;\n            };\n        }\n\n        s.data = null;\n        var beforeSend = s.beforeSend;\n        s.beforeSend = function(xhr, o) {\n            //Send FormData() provided by user\n            if (options.formData) {\n                o.data = options.formData;\n            }\n            else {\n                o.data = formdata;\n            }\n            if(beforeSend) {\n                beforeSend.call(this, xhr, o);\n            }\n        };\n        return $.ajax(s);\n    }\n\n    // private function for handling file uploads (hat tip to YAHOO!)\n    function fileUploadIframe(a) {\n        var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;\n        var deferred = $.Deferred();\n\n        // #341\n        deferred.abort = function(status) {\n            xhr.abort(status);\n        };\n\n        if (a) {\n            // ensure that every serialized input is still enabled\n            for (i=0; i < elements.length; i++) {\n                el = $(elements[i]);\n                if ( hasProp ) {\n                    el.prop('disabled', false);\n                }\n                else {\n                    el.removeAttr('disabled');\n                }\n            }\n        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n            $io = $(s.iframeTarget);\n            n = $io.attr2('name');\n            if (!n) {\n                $io.attr2('name', id);\n            }\n            else {\n                id = n;\n            }\n        }\n        else {\n            $io = $('<iframe name=\"' + id + '\" src=\"'+ s.iframeSrc +'\" />');\n            $io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });\n        }\n        io = $io[0];\n\n\n        xhr = { // mock object\n            aborted: 0,\n            responseText: null,\n            responseXML: null,\n            status: 0,\n            statusText: 'n/a',\n            getAllResponseHeaders: function() {},\n            getResponseHeader: function() {},\n            setRequestHeader: function() {},\n            abort: function(status) {\n                var e = (status === 'timeout' ? 'timeout' : 'aborted');\n                log('aborting upload... ' + e);\n                this.aborted = 1;\n\n                try { // #214, #257\n                    if (io.contentWindow.document.execCommand) {\n                        io.contentWindow.document.execCommand('Stop');\n                    }\n                }\n                catch(ignore) {}\n\n                $io.attr('src', s.iframeSrc); // abort op in progress\n                xhr.error = e;\n                if (s.error) {\n                    s.error.call(s.context, xhr, e, status);\n                }\n                if (g) {\n                    $.event.trigger(\"ajaxError\", [xhr, s, e]);\n                }\n                if (s.complete) {\n                    s.complete.call(s.context, xhr, e);\n                }\n            }\n        };\n\n        g = s.global;\n        // trigger ajax global events so that activity/block indicators work like normal\n        if (g && 0 === $.active++) {\n            $.event.trigger(\"ajaxStart\");\n        }\n        if (g) {\n            $.event.trigger(\"ajaxSend\", [xhr, s]);\n        }\n\n        if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {\n            if (s.global) {\n                $.active--;\n            }\n            deferred.reject();\n            return deferred;\n        }\n        if (xhr.aborted) {\n            deferred.reject();\n            return deferred;\n        }\n\n        // add submitting element to data if we know it\n        sub = form.clk;\n        if (sub) {\n            n = sub.name;\n            if (n && !sub.disabled) {\n                s.extraData = s.extraData || {};\n                s.extraData[n] = sub.value;\n                if (sub.type == \"image\") {\n                    s.extraData[n+'.x'] = form.clk_x;\n                    s.extraData[n+'.y'] = form.clk_y;\n                }\n            }\n        }\n\n        var CLIENT_TIMEOUT_ABORT = 1;\n        var SERVER_ABORT = 2;\n                \n        function getDoc(frame) {\n            /* it looks like contentWindow or contentDocument do not\n             * carry the protocol property in ie8, when running under ssl\n             * frame.document is the only valid response document, since\n             * the protocol is know but not on the other two objects. strange?\n             * \"Same origin policy\" http://en.wikipedia.org/wiki/Same_origin_policy\n             */\n            \n            var doc = null;\n            \n            // IE8 cascading access check\n            try {\n                if (frame.contentWindow) {\n                    doc = frame.contentWindow.document;\n                }\n            } catch(err) {\n                // IE8 access denied under ssl & missing protocol\n                log('cannot get iframe.contentWindow document: ' + err);\n            }\n\n            if (doc) { // successful getting content\n                return doc;\n            }\n\n            try { // simply checking may throw in ie8 under ssl or mismatched protocol\n                doc = frame.contentDocument ? frame.contentDocument : frame.document;\n            } catch(err) {\n                // last attempt\n                log('cannot get iframe.contentDocument: ' + err);\n                doc = frame.document;\n            }\n            return doc;\n        }\n\n        // Rails CSRF hack (thanks to Yvan Barthelemy)\n        var csrf_token = $('meta[name=csrf-token]').attr('content');\n        var csrf_param = $('meta[name=csrf-param]').attr('content');\n        if (csrf_param && csrf_token) {\n            s.extraData = s.extraData || {};\n            s.extraData[csrf_param] = csrf_token;\n        }\n\n        // take a breath so that pending repaints get some cpu time before the upload starts\n        function doSubmit() {\n            // make sure form attrs are set\n            var t = $form.attr2('target'), \n                a = $form.attr2('action'), \n                mp = 'multipart/form-data',\n                et = $form.attr('enctype') || $form.attr('encoding') || mp;\n\n            // update form attrs in IE friendly way\n            form.setAttribute('target',id);\n            if (!method || /post/i.test(method) ) {\n                form.setAttribute('method', 'POST');\n            }\n            if (a != s.url) {\n                form.setAttribute('action', s.url);\n            }\n\n            // ie borks in some cases when setting encoding\n            if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {\n                $form.attr({\n                    encoding: 'multipart/form-data',\n                    enctype:  'multipart/form-data'\n                });\n            }\n\n            // support timout\n            if (s.timeout) {\n                timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);\n            }\n\n            // look for server aborts\n            function checkState() {\n                try {\n                    var state = getDoc(io).readyState;\n                    log('state = ' + state);\n                    if (state && state.toLowerCase() == 'uninitialized') {\n                        setTimeout(checkState,50);\n                    }\n                }\n                catch(e) {\n                    log('Server abort: ' , e, ' (', e.name, ')');\n                    cb(SERVER_ABORT);\n                    if (timeoutHandle) {\n                        clearTimeout(timeoutHandle);\n                    }\n                    timeoutHandle = undefined;\n                }\n            }\n\n            // add \"extra\" data to form if provided in options\n            var extraInputs = [];\n            try {\n                if (s.extraData) {\n                    for (var n in s.extraData) {\n                        if (s.extraData.hasOwnProperty(n)) {\n                           // if using the $.param format that allows for multiple values with the same name\n                           if($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty('name') && s.extraData[n].hasOwnProperty('value')) {\n                               extraInputs.push(\n                               $('<input type=\"hidden\" name=\"'+s.extraData[n].name+'\">').val(s.extraData[n].value)\n                                   .appendTo(form)[0]);\n                           } else {\n                               extraInputs.push(\n                               $('<input type=\"hidden\" name=\"'+n+'\">').val(s.extraData[n])\n                                   .appendTo(form)[0]);\n                           }\n                        }\n                    }\n                }\n\n                if (!s.iframeTarget) {\n                    // add iframe to doc and submit the form\n                    $io.appendTo('body');\n                }\n                if (io.attachEvent) {\n                    io.attachEvent('onload', cb);\n                }\n                else {\n                    io.addEventListener('load', cb, false);\n                }\n                setTimeout(checkState,15);\n\n                try {\n                    form.submit();\n                } catch(err) {\n                    // just in case form has element with name/id of 'submit'\n                    var submitFn = document.createElement('form').submit;\n                    submitFn.apply(form);\n                }\n            }\n            finally {\n                // reset attrs and remove \"extra\" input elements\n                form.setAttribute('action',a);\n                form.setAttribute('enctype', et); // #380\n                if(t) {\n                    form.setAttribute('target', t);\n                } else {\n                    $form.removeAttr('target');\n                }\n                $(extraInputs).remove();\n            }\n        }\n\n        if (s.forceSync) {\n            doSubmit();\n        }\n        else {\n            setTimeout(doSubmit, 10); // this lets dom updates render\n        }\n\n        var data, doc, domCheckCount = 50, callbackProcessed;\n\n        function cb(e) {\n            if (xhr.aborted || callbackProcessed) {\n                return;\n            }\n            \n            doc = getDoc(io);\n            if(!doc) {\n                log('cannot access response document');\n                e = SERVER_ABORT;\n            }\n            if (e === CLIENT_TIMEOUT_ABORT && xhr) {\n                xhr.abort('timeout');\n                deferred.reject(xhr, 'timeout');\n                return;\n            }\n            else if (e == SERVER_ABORT && xhr) {\n                xhr.abort('server abort');\n                deferred.reject(xhr, 'error', 'server abort');\n                return;\n            }\n\n            if (!doc || doc.location.href == s.iframeSrc) {\n                // response not received yet\n                if (!timedOut) {\n                    return;\n                }\n            }\n            if (io.detachEvent) {\n                io.detachEvent('onload', cb);\n            }\n            else {\n                io.removeEventListener('load', cb, false);\n            }\n\n            var status = 'success', errMsg;\n            try {\n                if (timedOut) {\n                    throw 'timeout';\n                }\n\n                var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);\n                log('isXml='+isXml);\n                if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {\n                    if (--domCheckCount) {\n                        // in some browsers (Opera) the iframe DOM is not always traversable when\n                        // the onload callback fires, so we loop a bit to accommodate\n                        log('requeing onLoad callback, DOM not available');\n                        setTimeout(cb, 250);\n                        return;\n                    }\n                    // let this fall through because server response could be an empty document\n                    //log('Could not access iframe DOM after mutiple tries.');\n                    //throw 'DOMException: not available';\n                }\n\n                //log('response detected');\n                var docRoot = doc.body ? doc.body : doc.documentElement;\n                xhr.responseText = docRoot ? docRoot.innerHTML : null;\n                xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;\n                if (isXml) {\n                    s.dataType = 'xml';\n                }\n                xhr.getResponseHeader = function(header){\n                    var headers = {'content-type': s.dataType};\n                    return headers[header.toLowerCase()];\n                };\n                // support for XHR 'status' & 'statusText' emulation :\n                if (docRoot) {\n                    xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;\n                    xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;\n                }\n\n                var dt = (s.dataType || '').toLowerCase();\n                var scr = /(json|script|text)/.test(dt);\n                if (scr || s.textarea) {\n                    // see if user embedded response in textarea\n                    var ta = doc.getElementsByTagName('textarea')[0];\n                    if (ta) {\n                        xhr.responseText = ta.value;\n                        // support for XHR 'status' & 'statusText' emulation :\n                        xhr.status = Number( ta.getAttribute('status') ) || xhr.status;\n                        xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;\n                    }\n                    else if (scr) {\n                        // account for browsers injecting pre around json response\n                        var pre = doc.getElementsByTagName('pre')[0];\n                        var b = doc.getElementsByTagName('body')[0];\n                        if (pre) {\n                            xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;\n                        }\n                        else if (b) {\n                            xhr.responseText = b.textContent ? b.textContent : b.innerText;\n                        }\n                    }\n                }\n                else if (dt == 'xml' && !xhr.responseXML && xhr.responseText) {\n                    xhr.responseXML = toXml(xhr.responseText);\n                }\n\n                try {\n                    data = httpData(xhr, dt, s);\n                }\n                catch (err) {\n                    status = 'parsererror';\n                    xhr.error = errMsg = (err || status);\n                }\n            }\n            catch (err) {\n                log('error caught: ',err);\n                status = 'error';\n                xhr.error = errMsg = (err || status);\n            }\n\n            if (xhr.aborted) {\n                log('upload aborted');\n                status = null;\n            }\n\n            if (xhr.status) { // we've set xhr.status\n                status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';\n            }\n\n            // ordering of these callbacks/triggers is odd, but that's how $.ajax does it\n            if (status === 'success') {\n                if (s.success) {\n                    s.success.call(s.context, data, 'success', xhr);\n                }\n                deferred.resolve(xhr.responseText, 'success', xhr);\n                if (g) {\n                    $.event.trigger(\"ajaxSuccess\", [xhr, s]);\n                }\n            }\n            else if (status) {\n                if (errMsg === undefined) {\n                    errMsg = xhr.statusText;\n                }\n                if (s.error) {\n                    s.error.call(s.context, xhr, status, errMsg);\n                }\n                deferred.reject(xhr, 'error', errMsg);\n                if (g) {\n                    $.event.trigger(\"ajaxError\", [xhr, s, errMsg]);\n                }\n            }\n\n            if (g) {\n                $.event.trigger(\"ajaxComplete\", [xhr, s]);\n            }\n\n            if (g && ! --$.active) {\n                $.event.trigger(\"ajaxStop\");\n            }\n\n            if (s.complete) {\n                s.complete.call(s.context, xhr, status);\n            }\n\n            callbackProcessed = true;\n            if (s.timeout) {\n                clearTimeout(timeoutHandle);\n            }\n\n            // clean up\n            setTimeout(function() {\n                if (!s.iframeTarget) {\n                    $io.remove();\n                }\n                else { //adding else to clean up existing iframe response.\n                    $io.attr('src', s.iframeSrc);\n                }\n                xhr.responseXML = null;\n            }, 100);\n        }\n\n        var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)\n            if (window.ActiveXObject) {\n                doc = new ActiveXObject('Microsoft.XMLDOM');\n                doc.async = 'false';\n                doc.loadXML(s);\n            }\n            else {\n                doc = (new DOMParser()).parseFromString(s, 'text/xml');\n            }\n            return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;\n        };\n        var parseJSON = $.parseJSON || function(s) {\n            /*jslint evil:true */\n            return window['eval']('(' + s + ')');\n        };\n\n        var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4\n\n            var ct = xhr.getResponseHeader('content-type') || '',\n                xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,\n                data = xml ? xhr.responseXML : xhr.responseText;\n\n            if (xml && data.documentElement.nodeName === 'parsererror') {\n                if ($.error) {\n                    $.error('parsererror');\n                }\n            }\n            if (s && s.dataFilter) {\n                data = s.dataFilter(data, type);\n            }\n            if (typeof data === 'string') {\n                if (type === 'json' || !type && ct.indexOf('json') >= 0) {\n                    data = parseJSON(data);\n                } else if (type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0) {\n                    $.globalEval(data);\n                }\n            }\n            return data;\n        };\n\n        return deferred;\n    }\n};\n\n/**\n * ajaxForm() provides a mechanism for fully automating form submission.\n *\n * The advantages of using this method instead of ajaxSubmit() are:\n *\n * 1: This method will include coordinates for <input type=\"image\" /> elements (if the element\n *    is used to submit the form).\n * 2. This method will include the submit element's name/value data (for the element that was\n *    used to submit the form).\n * 3. This method binds the submit() method to the form for you.\n *\n * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely\n * passes the options argument along after properly binding events for submit elements and\n * the form itself.\n */\n$.fn.ajaxForm = function(options) {\n    options = options || {};\n    options.delegation = options.delegation && $.isFunction($.fn.on);\n\n    // in jQuery 1.3+ we can fix mistakes with the ready state\n    if (!options.delegation && this.length === 0) {\n        var o = { s: this.selector, c: this.context };\n        if (!$.isReady && o.s) {\n            log('DOM not ready, queuing ajaxForm');\n            $(function() {\n                $(o.s,o.c).ajaxForm(options);\n            });\n            return this;\n        }\n        // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()\n        log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));\n        return this;\n    }\n\n    if ( options.delegation ) {\n        $(document)\n            .off('submit.form-plugin', this.selector, doAjaxSubmit)\n            .off('click.form-plugin', this.selector, captureSubmittingElement)\n            .on('submit.form-plugin', this.selector, options, doAjaxSubmit)\n            .on('click.form-plugin', this.selector, options, captureSubmittingElement);\n        return this;\n    }\n\n    return this.ajaxFormUnbind()\n        .bind('submit.form-plugin', options, doAjaxSubmit)\n        .bind('click.form-plugin', options, captureSubmittingElement);\n};\n\n// private event handlers\nfunction doAjaxSubmit(e) {\n    /*jshint validthis:true */\n    var options = e.data;\n    if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed\n        e.preventDefault();\n        $(e.target).ajaxSubmit(options); // #365\n    }\n}\n\nfunction captureSubmittingElement(e) {\n    /*jshint validthis:true */\n    var target = e.target;\n    var $el = $(target);\n    if (!($el.is(\"[type=submit],[type=image]\"))) {\n        // is this a child element of the submit el?  (ex: a span within a button)\n        var t = $el.closest('[type=submit]');\n        if (t.length === 0) {\n            return;\n        }\n        target = t[0];\n    }\n    var form = this;\n    form.clk = target;\n    if (target.type == 'image') {\n        if (e.offsetX !== undefined) {\n            form.clk_x = e.offsetX;\n            form.clk_y = e.offsetY;\n        } else if (typeof $.fn.offset == 'function') {\n            var offset = $el.offset();\n            form.clk_x = e.pageX - offset.left;\n            form.clk_y = e.pageY - offset.top;\n        } else {\n            form.clk_x = e.pageX - target.offsetLeft;\n            form.clk_y = e.pageY - target.offsetTop;\n        }\n    }\n    // clear form vars\n    setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);\n}\n\n\n// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm\n$.fn.ajaxFormUnbind = function() {\n    return this.unbind('submit.form-plugin click.form-plugin');\n};\n\n/**\n * formToArray() gathers form element data into an array of objects that can\n * be passed to any of the following ajax functions: $.get, $.post, or load.\n * Each object in the array has both a 'name' and 'value' property.  An example of\n * an array for a simple login form might be:\n *\n * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]\n *\n * It is this array that is passed to pre-submit callback functions provided to the\n * ajaxSubmit() and ajaxForm() methods.\n */\n$.fn.formToArray = function(semantic, elements) {\n    var a = [];\n    if (this.length === 0) {\n        return a;\n    }\n\n    var form = this[0];\n    var formId = this.attr('id');\n    var els = semantic ? form.getElementsByTagName('*') : form.elements;\n    var els2;\n\n    if (els && !/MSIE [678]/.test(navigator.userAgent)) { // #390\n        els = $(els).get();  // convert to standard array\n    }\n\n    // #386; account for inputs outside the form which use the 'form' attribute\n    if ( formId ) {\n        els2 = $(':input[form=\"' + formId + '\"]').get(); // hat tip @thet\n        if ( els2.length ) {\n            els = (els || []).concat(els2);\n        }\n    }\n\n    if (!els || !els.length) {\n        return a;\n    }\n\n    var i,j,n,v,el,max,jmax;\n    for(i=0, max=els.length; i < max; i++) {\n        el = els[i];\n        n = el.name;\n        if (!n || el.disabled) {\n            continue;\n        }\n\n        if (semantic && form.clk && el.type == \"image\") {\n            // handle image inputs on the fly when semantic == true\n            if(form.clk == el) {\n                a.push({name: n, value: $(el).val(), type: el.type });\n                a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});\n            }\n            continue;\n        }\n\n        v = $.fieldValue(el, true);\n        if (v && v.constructor == Array) {\n            if (elements) {\n                elements.push(el);\n            }\n            for(j=0, jmax=v.length; j < jmax; j++) {\n                a.push({name: n, value: v[j]});\n            }\n        }\n        else if (feature.fileapi && el.type == 'file') {\n            if (elements) {\n                elements.push(el);\n            }\n            var files = el.files;\n            if (files.length) {\n                for (j=0; j < files.length; j++) {\n                    a.push({name: n, value: files[j], type: el.type});\n                }\n            }\n            else {\n                // #180\n                a.push({ name: n, value: '', type: el.type });\n            }\n        }\n        else if (v !== null && typeof v != 'undefined') {\n            if (elements) {\n                elements.push(el);\n            }\n            a.push({name: n, value: v, type: el.type, required: el.required});\n        }\n    }\n\n    if (!semantic && form.clk) {\n        // input type=='image' are not found in elements array! handle it here\n        var $input = $(form.clk), input = $input[0];\n        n = input.name;\n        if (n && !input.disabled && input.type == 'image') {\n            a.push({name: n, value: $input.val()});\n            a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});\n        }\n    }\n    return a;\n};\n\n/**\n * Serializes form data into a 'submittable' string. This method will return a string\n * in the format: name1=value1&amp;name2=value2\n */\n$.fn.formSerialize = function(semantic) {\n    //hand off to jQuery.param for proper encoding\n    return $.param(this.formToArray(semantic));\n};\n\n/**\n * Serializes all field elements in the jQuery object into a query string.\n * This method will return a string in the format: name1=value1&amp;name2=value2\n */\n$.fn.fieldSerialize = function(successful) {\n    var a = [];\n    this.each(function() {\n        var n = this.name;\n        if (!n) {\n            return;\n        }\n        var v = $.fieldValue(this, successful);\n        if (v && v.constructor == Array) {\n            for (var i=0,max=v.length; i < max; i++) {\n                a.push({name: n, value: v[i]});\n            }\n        }\n        else if (v !== null && typeof v != 'undefined') {\n            a.push({name: this.name, value: v});\n        }\n    });\n    //hand off to jQuery.param for proper encoding\n    return $.param(a);\n};\n\n/**\n * Returns the value(s) of the element in the matched set.  For example, consider the following form:\n *\n *  <form><fieldset>\n *      <input name=\"A\" type=\"text\" />\n *      <input name=\"A\" type=\"text\" />\n *      <input name=\"B\" type=\"checkbox\" value=\"B1\" />\n *      <input name=\"B\" type=\"checkbox\" value=\"B2\"/>\n *      <input name=\"C\" type=\"radio\" value=\"C1\" />\n *      <input name=\"C\" type=\"radio\" value=\"C2\" />\n *  </fieldset></form>\n *\n *  var v = $('input[type=text]').fieldValue();\n *  // if no values are entered into the text inputs\n *  v == ['','']\n *  // if values entered into the text inputs are 'foo' and 'bar'\n *  v == ['foo','bar']\n *\n *  var v = $('input[type=checkbox]').fieldValue();\n *  // if neither checkbox is checked\n *  v === undefined\n *  // if both checkboxes are checked\n *  v == ['B1', 'B2']\n *\n *  var v = $('input[type=radio]').fieldValue();\n *  // if neither radio is checked\n *  v === undefined\n *  // if first radio is checked\n *  v == ['C1']\n *\n * The successful argument controls whether or not the field element must be 'successful'\n * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).\n * The default value of the successful argument is true.  If this value is false the value(s)\n * for each element is returned.\n *\n * Note: This method *always* returns an array.  If no valid value can be determined the\n *    array will be empty, otherwise it will contain one or more values.\n */\n$.fn.fieldValue = function(successful) {\n    for (var val=[], i=0, max=this.length; i < max; i++) {\n        var el = this[i];\n        var v = $.fieldValue(el, successful);\n        if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {\n            continue;\n        }\n        if (v.constructor == Array) {\n            $.merge(val, v);\n        }\n        else {\n            val.push(v);\n        }\n    }\n    return val;\n};\n\n/**\n * Returns the value of the field element.\n */\n$.fieldValue = function(el, successful) {\n    var n = el.name, t = el.type, tag = el.tagName.toLowerCase();\n    if (successful === undefined) {\n        successful = true;\n    }\n\n    if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||\n        (t == 'checkbox' || t == 'radio') && !el.checked ||\n        (t == 'submit' || t == 'image') && el.form && el.form.clk != el ||\n        tag == 'select' && el.selectedIndex == -1)) {\n            return null;\n    }\n\n    if (tag == 'select') {\n        var index = el.selectedIndex;\n        if (index < 0) {\n            return null;\n        }\n        var a = [], ops = el.options;\n        var one = (t == 'select-one');\n        var max = (one ? index+1 : ops.length);\n        for(var i=(one ? index : 0); i < max; i++) {\n            var op = ops[i];\n            if (op.selected) {\n                var v = op.value;\n                if (!v) { // extra pain for IE...\n                    v = (op.attributes && op.attributes.value && !(op.attributes.value.specified)) ? op.text : op.value;\n                }\n                if (one) {\n                    return v;\n                }\n                a.push(v);\n            }\n        }\n        return a;\n    }\n    return $(el).val();\n};\n\n/**\n * Clears the form data.  Takes the following actions on the form's input fields:\n *  - input text fields will have their 'value' property set to the empty string\n *  - select elements will have their 'selectedIndex' property set to -1\n *  - checkbox and radio inputs will have their 'checked' property set to false\n *  - inputs of type submit, button, reset, and hidden will *not* be effected\n *  - button elements will *not* be effected\n */\n$.fn.clearForm = function(includeHidden) {\n    return this.each(function() {\n        $('input,select,textarea', this).clearFields(includeHidden);\n    });\n};\n\n/**\n * Clears the selected form elements.\n */\n$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {\n    var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list\n    return this.each(function() {\n        var t = this.type, tag = this.tagName.toLowerCase();\n        if (re.test(t) || tag == 'textarea') {\n            this.value = '';\n        }\n        else if (t == 'checkbox' || t == 'radio') {\n            this.checked = false;\n        }\n        else if (tag == 'select') {\n            this.selectedIndex = -1;\n        }\n        else if (t == \"file\") {\n            if (/MSIE/.test(navigator.userAgent)) {\n                $(this).replaceWith($(this).clone(true));\n            } else {\n                $(this).val('');\n            }\n        }\n        else if (includeHidden) {\n            // includeHidden can be the value true, or it can be a selector string\n            // indicating a special test; for example:\n            //  $('#myForm').clearForm('.special:hidden')\n            // the above would clean hidden inputs that have the class of 'special'\n            if ( (includeHidden === true && /hidden/.test(t)) ||\n                 (typeof includeHidden == 'string' && $(this).is(includeHidden)) ) {\n                this.value = '';\n            }\n        }\n    });\n};\n\n/**\n * Resets the form data.  Causes all form elements to be reset to their original value.\n */\n$.fn.resetForm = function() {\n    return this.each(function() {\n        // guard against an input with the name of 'reset'\n        // note that IE reports the reset function as an 'object'\n        if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {\n            this.reset();\n        }\n    });\n};\n\n/**\n * Enables or disables any matching elements.\n */\n$.fn.enable = function(b) {\n    if (b === undefined) {\n        b = true;\n    }\n    return this.each(function() {\n        this.disabled = !b;\n    });\n};\n\n/**\n * Checks/unchecks any matching checkboxes or radio buttons and\n * selects/deselects and matching option elements.\n */\n$.fn.selected = function(select) {\n    if (select === undefined) {\n        select = true;\n    }\n    return this.each(function() {\n        var t = this.type;\n        if (t == 'checkbox' || t == 'radio') {\n            this.checked = select;\n        }\n        else if (this.tagName.toLowerCase() == 'option') {\n            var $sel = $(this).parent('select');\n            if (select && $sel[0] && $sel[0].type == 'select-one') {\n                // deselect all other options\n                $sel.find('option').selected(false);\n            }\n            this.selected = select;\n        }\n    });\n};\n\n// expose debug var\n$.fn.ajaxSubmit.debug = false;\n\n// helper fn for console logging\nfunction log() {\n    if (!$.fn.ajaxSubmit.debug) {\n        return;\n    }\n    var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');\n    if (window.console && window.console.log) {\n        window.console.log(msg);\n    }\n    else if (window.opera && window.opera.postError) {\n        window.opera.postError(msg);\n    }\n}\n\n}));\n"
"/*!\r\n * jQuery Form Validation\r\n * Copyright (C) 2015 RunningCoder.org\r\n * Licensed under the MIT license\r\n *\r\n * @author Tom Bertrand\r\n * @version 1.5.3 (2015-06-14)\r\n * @link http://www.runningcoder.org/jqueryvalidation/\r\n*/\r\n;\n(function (window, document, $, undefined) {\n\n    window.Validation = {\n        form: [],\n        labels: {},\n        hasScrolled: false\n    };\n\n    /**\n     * Fail-safe preventExtensions function for older browsers\n     */\n    if (typeof Object.preventExtensions !== \"function\") {\n        Object.preventExtensions = function (obj) {\n            return obj;\n        };\n    }\n\n    // Not using strict to avoid throwing a window error on bad config extend.\n    // console.debug is used instead to debug Validation\n    //\"use strict\";\n\n    // =================================================================================================================\n    /**\n     * @private\n     * RegExp rules\n     */\n    var _rules = {\n        NOTEMPTY: /\\S/,\n        INTEGER: /^\\d+$/,\n        NUMERIC: /^\\d+(?:[,\\s]\\d{3})*(?:\\.\\d+)?$/,\n        MIXED: /^[\\w\\s-]+$/,\n        NAME: /^['a-zÃ£Ã Ã¡Ã¤Ã¢áº½Ã¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®ÃµÃ²Ã³Ã¶Ã´Ã¹ÃºÃ¼Ã»Ã±Ã§\\s-]+$/i,\n        NOSPACE: /^(?!\\s)\\S*$/,\n        TRIM: /^[^\\s].*[^\\s]$/,\n        DATE: /^\\d{4}-\\d{2}-\\d{2}(\\s\\d{2}:\\d{2}(:\\d{2})?)?$/,\n        EMAIL: /^([^@]+?)@(([a-z0-9]-*)*[a-z0-9]+\\.)+([a-z0-9]+)$/i,\n        URL: /^(https?:\\/\\/)?((([a-z0-9]-*)*[a-z0-9]+\\.?)*([a-z0-9]+))(\\/[\\w?=\\.-]*)*$/,\n        PHONE: /^(\\()?\\d{3}(\\))?(-|\\s)?\\d{3}(-|\\s)\\d{4}$/,\n        OPTIONAL: /\\S/,\n        COMPARISON: /^\\s*([LV])\\s*([<>]=?|==|!=)\\s*([^<>=!]+?)\\s*$/\n    };\n\n    /**\n     * @private\n     * Error messages\n     */\n    var _messages = {\n        'default': '$ contain error(s).',\n        'NOTEMPTY': '$ must not be empty.',\n        'INTEGER': '$ must be an integer.',\n        'NUMERIC': '$ must be numeric.',\n        'MIXED': '$ must be letters or numbers (no special characters).',\n        'NAME': '$ must not contain special characters.',\n        'NOSPACE': '$ must not contain spaces.',\n        'TRIM': '$ must not start or end with space character.',\n        'DATE': '$ is not a valid with format YYYY-MM-DD.',\n        'EMAIL': '$ is not valid.',\n        'URL': '$ is not valid.',\n        'PHONE': '$ is not a valid phone number.',\n        '<': '$ must be less than % characters.',\n        '<=': '$ must be less or equal to % characters.',\n        '>': '$ must be greater than % characters.',\n        '>=': '$ must be greater or equal to % characters.',\n        '==': '$ must be equal to %',\n        '!=': '$ must be different than %'\n    };\n\n    /**\n     * @private\n     * HTML5 data attributes\n     */\n    var _data = {\n        validation: 'data-validation',\n        validationMessage: 'data-validation-message',\n        regex: 'data-validation-regex',\n        regexReverse: 'data-validation-regex-reverse',\n        regexMessage: 'data-validation-regex-message',\n        group: 'data-validation-group',\n        label: 'data-validation-label',\n        errorList: 'data-error-list'\n    }\n\n    /**\n     * @private\n     * Default options\n     *\n     * @link http://www.runningcoder.org/jqueryvalidation/documentation/\n     */\n    var _options = {\n        submit: {\n            settings: {\n                form: null,\n                display: \"inline\",\n                insertion: \"append\",\n                allErrors: false,\n                trigger: \"click\",\n                button: \"[type='submit']\",\n                errorClass: \"error\",\n                errorListClass: \"error-list\",\n                errorListContainer: null,\n                inputContainer: null,\n                clear: \"focusin\",\n                scrollToError: false\n            },\n            callback: {\n                onInit: null,\n                onValidate: null,\n                onError: null,\n                onBeforeSubmit: null,\n                onSubmit: null,\n                onAfterSubmit: null\n            }\n        },\n        dynamic: {\n            settings: {\n                trigger: null,\n                delay: 300\n            },\n            callback: {\n                onSuccess: null,\n                onError: null,\n                onComplete: null\n            }\n        },\n        rules: {},\n        messages: {},\n        labels: {},\n        debug: false\n    };\n\n    /**\n     * @private\n     * Limit the supported options on matching keys\n     */\n    var _supported = {\n        submit: {\n            settings: {\n                display: [\"inline\", \"block\"],\n                insertion: [\"append\", \"prepend\"], //\"before\", \"insertBefore\", \"after\", \"insertAfter\"\n                allErrors: [true, false],\n                clear: [\"focusin\", \"keypress\", false],\n                trigger: [\n                    \"click\", \"dblclick\", \"focusout\",\n                    \"hover\", \"mousedown\", \"mouseenter\",\n                    \"mouseleave\", \"mousemove\", \"mouseout\",\n                    \"mouseover\", \"mouseup\", \"toggle\"\n                ]\n            }\n        },\n        dynamic: {\n            settings: {\n                trigger: [\"focusout\", \"keydown\", \"keypress\", \"keyup\"]\n            }\n        },\n        debug: [true, false]\n    };\n\n    // =================================================================================================================\n\n    /**\n     * @constructor\n     * Validation Class\n     *\n     * @param {Object} node jQuery form object\n     * @param {Object} options User defined options\n     */\n    var Validation = function (node, options) {\n\n        var errors = [],\n            messages = {},\n            formData = {},\n            delegateSuffix = \".vd\", // validation.delegate\n            resetSuffix = \".vr\";    // validation.resetError\n\n        window.Validation.hasScrolled = false;\n\n        /**\n         * Extends user-defined \"options.message\" into the default Validation \"_message\".\n         */\n        function extendRules() {\n            options.rules = $.extend(\n                true,\n                {},\n                _rules,\n                options.rules\n            );\n        }\n\n        /**\n         * Extends user-defined \"options.message\" into the default Validation \"_message\".\n         */\n        function extendMessages() {\n            options.messages = $.extend(\n                true,\n                {},\n                _messages,\n                options.messages\n            );\n        }\n\n        /**\n         * Extends user-defined \"options\" into the default Validation \"_options\".\n         * Notes:\n         *  - preventExtensions prevents from modifying the Validation \"_options\" object structure\n         *  - filter through the \"_supported\" to delete unsupported \"options\"\n         */\n        function extendOptions() {\n\n            if (!(options instanceof Object)) {\n                options = {};\n            }\n\n            var tpmOptions = Object.preventExtensions($.extend(true, {}, _options));\n\n            for (var method in options) {\n\n                if (!options.hasOwnProperty(method) || method === \"debug\") {\n                    continue;\n                }\n\n                if (~[\"labels\", \"messages\", \"rules\"].indexOf(method) && options[method] instanceof Object) {\n                    tpmOptions[method] = options[method];\n                    continue;\n                }\n\n                if (!_options[method] || !(options[method] instanceof Object)) {\n\n                    // {debug}\n                    options.debug && window.Debug.log({\n                        'node': node,\n                        'function': 'extendOptions()',\n                        'arguments': '{' + method + ': ' + JSON.stringify(options[method]) + '}',\n                        'message': 'WARNING - ' + method + ' - invalid option'\n                    });\n                    // {/debug}\n\n                    continue;\n                }\n\n                for (var type in options[method]) {\n                    if (!options[method].hasOwnProperty(type)) {\n                        continue;\n                    }\n\n                    if (!_options[method][type] || !(options[method][type] instanceof Object)) {\n\n                        // {debug}\n                        options.debug && window.Debug.log({\n                            'node': node,\n                            'function': 'extendOptions()',\n                            'arguments': '{' + type + ': ' + JSON.stringify(options[method][type]) + '}',\n                            'message': 'WARNING - ' + type + ' - invalid option'\n                        });\n                        // {/debug}\n\n                        continue;\n                    }\n\n                    for (var option in options[method][type]) {\n                        if (!options[method][type].hasOwnProperty(option)) {\n                            continue;\n                        }\n\n                        if (_supported[method] &&\n                            _supported[method][type] &&\n                            _supported[method][type][option] &&\n                            $.inArray(options[method][type][option], _supported[method][type][option]) === -1) {\n\n                            // {debug}\n                            options.debug && window.Debug.log({\n                                'node': node,\n                                'function': 'extendOptions()',\n                                'arguments': '{' + option + ': ' + JSON.stringify(options[method][type][option]) + '}',\n                                'message': 'WARNING - ' + option.toString() + ': ' + JSON.stringify(options[method][type][option]) + ' - unsupported option'\n                            });\n                            // {/debug}\n\n                            delete options[method][type][option];\n                        }\n\n                    }\n                    if (tpmOptions[method] && tpmOptions[method][type]) {\n                        tpmOptions[method][type] = $.extend(Object.preventExtensions(tpmOptions[method][type]), options[method][type]);\n                    }\n                }\n            }\n\n            // {debug}\n            if (options.debug && $.inArray(options.debug, _supported.debug !== -1)) {\n                tpmOptions.debug = options.debug;\n            }\n            // {/debug}\n\n            // @TODO Would there be a better fix to solve event conflict?\n            if (tpmOptions.dynamic.settings.trigger) {\n                if (tpmOptions.dynamic.settings.trigger === \"keypress\" && tpmOptions.submit.settings.clear === \"keypress\") {\n                    tpmOptions.dynamic.settings.trigger = \"keydown\";\n                }\n            }\n\n            options = tpmOptions;\n\n        }\n\n        /**\n         * Delegates the dynamic validation on data-validation and data-validation-regex attributes based on trigger.\n         *\n         * @returns {Boolean} false if the option is not set\n         */\n        function delegateDynamicValidation() {\n\n            if (!options.dynamic.settings.trigger) {\n                return false;\n            }\n\n            // {debug}\n            options.debug && window.Debug.log({\n                'node': node,\n                'function': 'delegateDynamicValidation()',\n                'message': 'OK - Dynamic Validation activated on ' + node.length + ' form(s)'\n            });\n            // {/debug}\n\n            if (!node.find('[' + _data.validation + '],[' + _data.regex + ']')[0]) {\n\n                // {debug}\n                options.debug && window.Debug.log({\n                    'node': node,\n                    'function': 'delegateDynamicValidation()',\n                    'arguments': 'node.find([' + _data.validation + '],[' + _data.regex + '])',\n                    'message': 'ERROR - [' + _data.validation + '] not found'\n                });\n                // {/debug}\n\n                return false;\n            }\n\n            var event = options.dynamic.settings.trigger + delegateSuffix;\n            if (options.dynamic.settings.trigger !== \"focusout\") {\n                event += \" change\" + delegateSuffix + \" paste\" + delegateSuffix;\n            }\n\n            $.each(\n                node.find('[' + _data.validation + '],[' + _data.regex + ']'),\n                function (index, input) {\n\n                    $(input).unbind(event).on(event, function (e) {\n\n                        if ($(this).is(':disabled')) {\n                            return false;\n                        }\n\n                        //e.preventDefault();\n\n                        var input = this,\n                            keyCode = e.keyCode || null;\n\n                        _typeWatch(function () {\n\n                            if (!validateInput(input)) {\n\n                                displayOneError(input.name);\n                                _executeCallback(options.dynamic.callback.onError, [node, input, keyCode, errors[input.name]]);\n\n                            } else {\n\n                                _executeCallback(options.dynamic.callback.onSuccess, [node, input, keyCode]);\n\n                            }\n\n                            _executeCallback(options.dynamic.callback.onComplete, [node, input, keyCode]);\n\n                        }, options.dynamic.settings.delay);\n\n                    });\n                }\n            );\n        }\n\n        /**\n         * Delegates the submit validation on data-validation and data-validation-regex attributes based on trigger.\n         * Note: Disable the form submit function so the callbacks are not by-passed\n         */\n        function delegateValidation() {\n\n            _executeCallback(options.submit.callback.onInit, [node]);\n\n            var event = options.submit.settings.trigger + '.vd';\n\n            // {debug}\n            options.debug && window.Debug.log({\n                'node': node,\n                'function': 'delegateValidation()',\n                'message': 'OK - Validation activated on ' + node.length + ' form(s)'\n            });\n            // {/debug}\n\n            if (!node.find(options.submit.settings.button)[0]) {\n\n                // {debug}\n                options.debug && window.Debug.log({\n                    'node': node,\n                    'function': 'delegateValidation()',\n                    'arguments': '{button: ' + options.submit.settings.button + '}',\n                    'message': 'ERROR - node.find(\"' + options.submit.settings.button + '\") not found'\n                });\n                // {/debug}\n\n                return false;\n\n            }\n\n            node.on(\"submit\", false);\n            node.find(options.submit.settings.button).off('.vd').on(event, function (e) {\n\n                e.preventDefault();\n\n                resetErrors();\n\n                _executeCallback(options.submit.callback.onValidate, [node]);\n\n                if (!validateForm()) {\n\n                    displayErrors();\n                    _executeCallback(options.submit.callback.onError, [node, errors, formData]);\n\n                } else {\n\n                    _executeCallback(options.submit.callback.onBeforeSubmit, [node]);\n\n                    (options.submit.callback.onSubmit) ? _executeCallback(options.submit.callback.onSubmit, [node, formData]) : submitForm();\n\n                    _executeCallback(options.submit.callback.onAfterSubmit, [node]);\n\n                }\n\n                // {debug}\n                options.debug && window.Debug.print();\n                // {/debug}\n\n                return false;\n\n            });\n\n        }\n\n        /**\n         * For every \"data-validation\" & \"data-pattern\" attributes that are not disabled inside the jQuery \"node\" object\n         * the \"validateInput\" function will be called.\n         *\n         * @returns {Boolean} true if no error(s) were found (valid form)\n         */\n        function validateForm() {\n\n            var isValid = true;\n\n            formData = {};\n\n\n            $.each(\n                node.find('input:not([type=\"submit\"]), select, textarea'),\n                function (index, input) {\n\n                    input = $(input);\n\n                    var value = _getInputValue(input[0]),\n                        inputName = input.attr('name');\n\n                    if (inputName) {\n                        formData[inputName] = value;\n                    }\n\n                    if (!input.attr('disabled') && (!!input.attr(_data.validation) || !!input.attr(_data.regex))) {\n                        if (!validateInput(input[0], value)) {\n                            isValid = false;\n                        }\n                    }\n                }\n            );\n\n            prepareFormData();\n\n            return isValid;\n\n        }\n\n        /**\n         * Loop through formData and build an object\n         *\n         * @returns {Object} data\n         */\n        function prepareFormData() {\n\n            var data = {},\n                matches,\n                index;\n\n            for (var i in formData) {\n                if (!formData.hasOwnProperty(i)) continue;\n\n                index = 0;\n                matches = i.split(/\\[(.+?)]/g);\n\n                var tmpObject = {},\n                    tmpArray = [];\n\n                for (var k = matches.length - 1; k >= 0; k--) {\n                    if (matches[k] === \"\") {\n                        matches.splice(k, 1);\n                        continue;\n                    }\n\n                    if (tmpArray.length < 1) {\n                        tmpObject[matches[k]] = Number(formData[i]) || formData[i];\n                    } else {\n                        tmpObject = {};\n                        tmpObject[matches[k]] = tmpArray[tmpArray.length - 1];\n                    }\n                    tmpArray.push(tmpObject)\n\n                }\n\n                data = $.extend(true, data, tmpObject);\n\n            }\n\n            formData = data;\n\n        }\n\n        /**\n         * Prepare the information from the data attributes\n         * and call the \"validateRule\" function.\n         *\n         * @param {Object} input Reference of the input element\n         *\n         * @returns {Boolean} true if no error(s) were found (valid input)\n         */\n        function validateInput(input, value) {\n\n            var inputName = $(input).attr('name'),\n                value = value || _getInputValue(input);\n\n            if (!inputName) {\n\n                // {debug}\n                options.debug && window.Debug.log({\n                    'node': node,\n                    'function': 'validateInput()',\n                    'arguments': '$(input).attr(\"name\")',\n                    'message': 'ERROR - Missing input [name]'\n                });\n                // {/debug}\n\n                return false;\n            }\n\n            var matches = inputName.replace(/]$/, '').split(/]\\[|[[\\]]/g),\n                inputShortName = window.Validation.labels[inputName] ||\n                    options.labels[inputName] ||\n                    $(input).attr(_data.label) ||\n                    matches[matches.length - 1],\n\n                validationArray = $(input).attr(_data.validation),\n                validationMessage = $(input).attr(_data.validationMessage),\n                validationRegex = $(input).attr(_data.regex),\n                validationRegexReverse = !($(input).attr(_data.regexReverse) === undefined),\n                validationRegexMessage = $(input).attr(_data.regexMessage),\n\n                validateOnce = false;\n\n            if (validationArray) {\n                validationArray = _api._splitValidation(validationArray);\n            }\n\n            // Validates the \"data-validation\"\n            if (validationArray instanceof Array && validationArray.length > 0) {\n\n                // \"OPTIONAL\" input will not be validated if it's empty\n                if ($.trim(value) === '' && ~validationArray.indexOf('OPTIONAL')) {\n                    return true;\n                }\n\n                $.each(validationArray, function (i, rule) {\n\n                    if (validateOnce === true) {\n                        return true;\n                    }\n\n                    try {\n\n                        validateRule(value, rule);\n\n                    } catch (error) {\n\n                        if (validationMessage || !options.submit.settings.allErrors) {\n                            validateOnce = true;\n                        }\n\n                        error[0] = validationMessage || error[0];\n\n                        registerError(inputName, error[0].replace('$', inputShortName).replace('%', error[1]));\n\n                    }\n\n                });\n\n            }\n\n            // Validates the \"data-validation-regex\"\n            if (validationRegex) {\n\n                var rule = _buildRegexFromString(validationRegex);\n\n                // Do not block validation if a regexp is bad, only skip it\n                if (!(rule instanceof RegExp)) {\n                    return true;\n                }\n\n                try {\n\n                    validateRule(value, rule, validationRegexReverse);\n\n                } catch (error) {\n\n                    error[0] = validationRegexMessage || error[0];\n\n                    registerError(inputName, error[0].replace('$', inputShortName));\n\n                }\n\n            }\n\n            return !errors[inputName] || errors[inputName] instanceof Array && errors[inputName].length === 0;\n\n        }\n\n        /**\n         * Validate an input value against one rule.\n         * If a \"value-rule\" mismatch occurs, an error is thrown to the caller function.\n         *\n         * @param {String} value\n         * @param {*} rule\n         * @param {Boolean} [reversed]\n         *\n         * @returns {*} Error if a mismatch occurred.\n         */\n        function validateRule(value, rule, reversed) {\n\n            // Validate for \"data-validation-regex\" and \"data-validation-regex-reverse\"\n            if (rule instanceof RegExp) {\n                var isValid = rule.test(value);\n\n                if (reversed) {\n                    isValid = !isValid;\n                }\n\n                if (!isValid) {\n                    throw [options.messages['default'], ''];\n                }\n                return;\n            }\n\n            if (options.rules[rule]) {\n                if (!options.rules[rule].test(value)) {\n                    throw [options.messages[rule], ''];\n                }\n                return;\n            }\n\n            // Validate for comparison \"data-validation\"\n            var comparison = rule.match(options.rules.COMPARISON);\n\n            if (!comparison || comparison.length !== 4) {\n\n                // {debug}\n                options.debug && window.Debug.log({\n                    'node': node,\n                    'function': 'validateRule()',\n                    'arguments': 'value: ' + value + ' rule: ' + rule,\n                    'message': 'WARNING - Invalid comparison'\n                });\n                // {/debug}\n\n                return;\n            }\n\n            var type = comparison[1],\n                operator = comparison[2],\n                compared = comparison[3],\n                comparedValue;\n\n            switch (type) {\n\n                // Compare input \"Length\"\n                case \"L\":\n\n                    // Only numeric value for \"L\" are allowed\n                    if (isNaN(compared)) {\n\n                        // {debug}\n                        options.debug && window.Debug.log({\n                            'node': node,\n                            'function': 'validateRule()',\n                            'arguments': 'compare: ' + compared + ' rule: ' + rule,\n                            'message': 'WARNING - Invalid rule, \"L\" compare must be numeric'\n                        });\n                        // {/debug}\n\n                        return false;\n\n                    } else {\n\n                        if (!value || eval(value.length + operator + parseFloat(compared)) === false) {\n                            throw [options.messages[operator], compared];\n                        }\n\n                    }\n\n                    break;\n\n                // Compare input \"Value\"\n                case \"V\":\n                default:\n\n                    // Compare Field values\n                    if (isNaN(compared)) {\n\n                        comparedValue = node.find('[name=\"' + compared + '\"]').val();\n                        if (!comparedValue) {\n\n                            // {debug}\n                            options.debug && window.Debug.log({\n                                'node': node,\n                                'function': 'validateRule()',\n                                'arguments': 'compare: ' + compared + ' rule: ' + rule,\n                                'message': 'WARNING - Unable to find compared field [name=\"' + compared + '\"]'\n                            });\n                            // {/debug}\n\n                            return false;\n                        }\n\n                        if (!value || !eval('\"' + encodeURIComponent(value) + '\"' + operator + '\"' + encodeURIComponent(comparedValue) + '\"')) {\n                            throw [options.messages[operator].replace(' characters', ''), compared];\n                        }\n\n                    } else {\n                        // Compare numeric value\n                        if (!value || isNaN(value) || !eval(value + operator + parseFloat(compared))) {\n                            throw [options.messages[operator].replace(' characters', ''), compared];\n                        }\n\n                    }\n                    break;\n\n            }\n\n        }\n\n        /**\n         * Register an error into the global \"error\" variable.\n         *\n         * @param {String} inputName Input where the error occurred\n         * @param {String} error Description of the error to be displayed\n         */\n        function registerError(inputName, error) {\n\n            if (!errors[inputName]) {\n                errors[inputName] = [];\n            }\n\n            error = error.capitalize();\n\n            var hasError = false;\n            for (var i = 0; i < errors[inputName].length; i++) {\n                if (errors[inputName][i] === error) {\n                    hasError = true;\n                    break;\n                }\n            }\n\n            if (!hasError) {\n                errors[inputName].push(error);\n            }\n\n        }\n\n        /**\n         * Display a single error based on \"inputName\" key inside the \"errors\" global array.\n         * The input, the label and the \"inputContainer\" will be given the \"errorClass\" and other\n         * settings will be considered.\n         *\n         * @param {String} inputName Key used for search into \"errors\"\n         *\n         * @returns {Boolean} false if an unwanted behavior occurs\n         */\n        function displayOneError(inputName) {\n\n            var input,\n                inputId,\n                errorContainer,\n                label,\n                html = '<div class=\"' + options.submit.settings.errorListClass + '\" ' + _data.errorList + '><ul></ul></div>',\n                group,\n                groupInput;\n\n            if (!errors.hasOwnProperty(inputName)) {\n                return false;\n            }\n\n            input = node.find('[name=\"' + inputName + '\"]');\n\n            label = null;\n\n            if (!input[0]) {\n\n                // {debug}\n                options.debug && window.Debug.log({\n                    'node': node,\n                    'function': 'displayOneError()',\n                    'arguments': '[name=\"' + inputName + '\"]',\n                    'message': 'ERROR - Unable to find input by name \"' + inputName + '\"'\n                });\n                // {/debug}\n\n                return false;\n            }\n\n            group = input.attr(_data.group);\n\n            if (group) {\n\n                groupInput = node.find('[name=\"' + inputName + '\"]');\n                label = node.find('[id=\"' + group + '\"]');\n\n                if (label[0]) {\n                    label.addClass(options.submit.settings.errorClass);\n                    errorContainer = label;\n                }\n\n                //node.find('[' + _data.group + '=\"' + group + '\"]').addClass(options.submit.settings.errorClass)\n\n            } else {\n\n                input.addClass(options.submit.settings.errorClass);\n\n                if (options.submit.settings.inputContainer) {\n                    input.parentsUntil(node, options.submit.settings.inputContainer).addClass(options.submit.settings.errorClass);\n                }\n\n                inputId = input.attr('id');\n\n                if (inputId) {\n                    label = node.find('label[for=\"' + inputId + '\"]')[0];\n                }\n\n                if (!label) {\n                    label = input.parentsUntil(node, 'label')[0];\n                }\n\n                if (label) {\n                    label = $(label);\n                    label.addClass(options.submit.settings.errorClass);\n                }\n            }\n\n            if (options.submit.settings.display === 'inline') {\n                if (options.submit.settings.errorListContainer) {\n                    errorContainer = input.parentsUntil(node, options.submit.settings.errorListContainer);\n                } else {\n                    errorContainer = errorContainer || input.parent();\n                }\n            } else if (options.submit.settings.display === 'block') {\n                errorContainer = node;\n            }\n\n            // Prevent double error list if the previous one has not been cleared.\n            if (options.submit.settings.display === 'inline' && errorContainer.find('[' + _data.errorList + ']')[0]) {\n                return false;\n            }\n\n            if (options.submit.settings.display === \"inline\" ||\n                (options.submit.settings.display === \"block\" && !errorContainer.find('[' + _data.errorList + ']')[0])\n                ) {\n                if (options.submit.settings.insertion === 'append') {\n                    errorContainer.append(html);\n                } else if (options.submit.settings.insertion === 'prepend') {\n                    errorContainer.prepend(html);\n                }\n            }\n\n            for (var i = 0; i < errors[inputName].length; i++) {\n                errorContainer.find('[' + _data.errorList + '] ul').append('<li>' + errors[inputName][i] + '</li>');\n            }\n\n            if (options.submit.settings.clear || options.dynamic.settings.trigger) {\n\n                if (group && groupInput) {\n                    input = groupInput;\n                }\n\n                var event = \"coucou\" + resetSuffix;\n                if (options.submit.settings.clear) {\n                    event += \" \" + options.submit.settings.clear + resetSuffix;\n                    if (~['radio', 'checkbox'].indexOf(input[0].type)) {\n                        event += \" change\" + resetSuffix;\n                    }\n                }\n                if (options.dynamic.settings.trigger) {\n                    event += \" \" + options.dynamic.settings.trigger + resetSuffix;\n                    if (options.dynamic.settings.trigger !== \"focusout\" && !~['radio', 'checkbox'].indexOf(input[0].type)) {\n                        event += \" change\" + resetSuffix + \" paste\" + resetSuffix;\n                    }\n                }\n\n                input.unbind(event).on(event, function (a, b, c, d, e) {\n\n                    return function () {\n                        if (e) {\n                            if ($(c).hasClass(options.submit.settings.errorClass)) {\n                                resetOneError(a, b, c, d, e);\n                            }\n                        } else if ($(b).hasClass(options.submit.settings.errorClass)) {\n                            resetOneError(a, b, c, d);\n                        }\n                    };\n\n                }(inputName, input, label, errorContainer, group));\n            }\n\n            if (options.submit.settings.scrollToError && !window.Validation.hasScrolled) {\n\n                window.Validation.hasScrolled = true;\n\n                var offset = parseFloat(options.submit.settings.scrollToError.offset) || 0,\n                    duration = parseFloat(options.submit.settings.scrollToError.duration) || 500,\n                    handle = (options.submit.settings.display === 'block') ? errorContainer : input;\n\n                $('html, body').animate({\n                    scrollTop: handle.offset().top + offset\n                }, duration);\n\n            }\n\n        }\n\n        /**\n         * Display all of the errors\n         */\n        function displayErrors() {\n\n            for (var inputName in errors) {\n                if (!errors.hasOwnProperty(inputName)) continue;\n                displayOneError(inputName);\n            }\n\n        }\n\n        /**\n         * Remove an input error.\n         *\n         * @param {String} inputName Key reference to delete the error from \"errors\" global variable\n         * @param {Object} input jQuery object of the input\n         * @param {Object} label jQuery object of the input's label\n         * @param {Object} container jQuery object of the \"errorList\"\n         * @param {String} [group] Name of the group if any (ex: used on input radio)\n         */\n        function resetOneError(inputName, input, label, container, group) {\n\n            delete errors[inputName];\n\n            if (container) {\n\n                //window.Validation.hasScrolled = false;\n\n                if (options.submit.settings.inputContainer) {\n                    (group ? label : input).parentsUntil(node, options.submit.settings.inputContainer).removeClass(options.submit.settings.errorClass);\n                }\n\n                label && label.removeClass(options.submit.settings.errorClass);\n\n                input.removeClass(options.submit.settings.errorClass);\n\n                if (options.submit.settings.display === 'inline') {\n                    container.find('[' + _data.errorList + ']').remove();\n                }\n\n            } else {\n\n                if (!input) {\n                    input = node.find('[name=\"' + inputName + '\"]');\n\n                    if (!input[0]) {\n\n                        // {debug}\n                        options.debug && window.Debug.log({\n                            'node': node,\n                            'function': 'resetOneError()',\n                            'arguments': '[name=\"' + inputName + '\"]',\n                            'message': 'ERROR - Unable to find input by name \"' + inputName + '\"'\n                        });\n                        // {/debug}\n\n                        return false;\n                    }\n                }\n\n                input.trigger('coucou' + resetSuffix);\n            }\n\n        }\n\n        /**\n         * Remove all of the input error(s) display.\n         */\n        function resetErrors() {\n\n            errors = [];\n            window.Validation.hasScrolled = false;\n\n            node.find('[' + _data.errorList + ']').remove();\n            node.find('.' + options.submit.settings.errorClass).removeClass(options.submit.settings.errorClass);\n\n        }\n\n        /**\n         * Submits the form once it succeeded the validation process.\n         * Note:\n         * - This function will be overridden if \"options.submit.settings.onSubmit\" is defined\n         * - The node can't be submitted by jQuery since it has been disabled, use the form native submit function instead\n         */\n        function submitForm() {\n\n            node[0].submit()\n\n        }\n\n        /**\n         * Destroy the Validation instance\n         *\n         * @returns {Boolean}\n         */\n        function destroy() {\n\n            resetErrors();\n            node.find('[' + _data.validation + '],[' + _data.regex + ']').off(delegateSuffix + ' ' + resetSuffix);\n\n            node.find(options.submit.settings.button).off(delegateSuffix).on('click' + delegateSuffix, function () {\n                $(this).closest('form')[0].submit();\n            });\n\n            //delete window.Validation.form[node.selector];\n\n            return true;\n\n        }\n\n        /**\n         * @private\n         * Helper to get the value of an regular, radio or chackbox input\n         *\n         * @param input\n         *\n         * @returns {String} value\n         */\n        var _getInputValue = function (input) {\n\n            var value;\n\n            // Get the value or state of the input based on its type\n            switch ($(input).attr('type')) {\n                case 'checkbox':\n                    value = ($(input).is(':checked')) ? 1 : '';\n                    break;\n                case 'radio':\n                    value = node.find('input[name=\"' + $(input).attr('name') + '\"]:checked').val() || '';\n                    break;\n                default:\n                    value = $(input).val();\n                    break;\n            }\n\n            return value;\n\n        };\n\n        /**\n         * @private\n         * Execute function once the timer is reached.\n         * If the function is recalled before the timer ends, the first call will be canceled.\n         */\n        var _typeWatch = (function () {\n            var timer = 0;\n            return function (callback, ms) {\n                clearTimeout(timer);\n                timer = setTimeout(callback, ms);\n            };\n        })();\n\n        /**\n         * @private\n         * Executes an anonymous function or a string reached from the window scope.\n         *\n         * @example\n         * Note: These examples works with every callbacks (onInit, onError, onSubmit, onBeforeSubmit & onAfterSubmit)\n         *\n         * // An anonymous function inside the \"onInit\" option\n         * onInit: function() { console.log(':D'); };\n         *\n         * * // myFunction() located on window.coucou scope\n         * onInit: 'window.coucou.myFunction'\n         *\n         * // myFunction(a,b) located on window.coucou scope passing 2 parameters\n         * onInit: ['window.coucou.myFunction', [':D', ':)']];\n         *\n         * // Anonymous function to execute a local function\n         * onInit: function () { myFunction(':D'); }\n         *\n         * @param {String|Array} callback The function to be called\n         * @param {Array} [extraParams] In some cases the function can be called with Extra parameters (onError)\n         *\n         * @returns {Boolean}\n         */\n        var _executeCallback = function (callback, extraParams) {\n\n            if (!callback) {\n                return false;\n            }\n\n            var _callback;\n\n            if (typeof callback === \"function\") {\n\n                _callback = callback;\n\n            } else if (typeof callback === \"string\" || callback instanceof Array) {\n\n                _callback = window;\n\n                if (typeof callback === \"string\") {\n                    callback = [callback, []];\n                }\n\n                var _exploded = callback[0].split('.'),\n                    _params = callback[1],\n                    _isValid = true,\n                    _splitIndex = 0;\n\n                while (_splitIndex < _exploded.length) {\n\n                    if (typeof _callback !== 'undefined') {\n                        _callback = _callback[_exploded[_splitIndex++]];\n                    } else {\n                        _isValid = false;\n                        break;\n                    }\n                }\n\n                if (!_isValid || typeof _callback !== \"function\") {\n\n                    // {debug}\n                    options.debug && window.Debug.log({\n                        'node': node,\n                        'function': '_executeCallback()',\n                        'arguments': JSON.stringify(callback),\n                        'message': 'WARNING - Invalid callback function\"'\n                    });\n                    // {/debug}\n\n                    return false;\n                }\n\n            }\n\n            _callback.apply(this, $.merge(_params || [], (extraParams) ? extraParams : []));\n            return true;\n\n        };\n\n        /**\n         * @private\n         * Constructs Validation\n         */\n        this.__construct = function () {\n\n            extendOptions();\n            extendRules();\n            extendMessages();\n\n            delegateDynamicValidation();\n            delegateValidation();\n\n            // {debug}\n            options.debug && window.Debug.print();\n            // {/debug}\n\n        }();\n\n        return {\n\n            /**\n             * @public\n             * Register error\n             *\n             * @param inputName\n             * @param error\n             */\n            registerError: registerError,\n\n            /**\n             * @public\n             * Display one error\n             *\n             * @param inputName\n             */\n            displayOneError: displayOneError,\n\n            /**\n             * @public\n             * Display all errors\n             */\n            displayErrors: displayErrors,\n\n            /**\n             * @public\n             * Remove one error\n             */\n            resetOneError: resetOneError,\n\n            /**\n             * @public\n             * Remove all errors\n             */\n            resetErrors: resetErrors,\n\n            /**\n             * @public\n             * Destroy the Validation instance\n             */\n            destroy: destroy\n\n        };\n\n    };\n\n    // =================================================================================================================\n\n    /**\n     * @public\n     * jQuery public function to implement the Validation on the selected node(s).\n     *\n     * @param {object} options To configure the Validation class.\n     *\n     * @return {object} Modified DOM element\n     */\n    $.fn.validate = $.validate = function (options) {\n\n        return _api.validate(this, options);\n\n    };\n\n    /**\n     * @public\n     * jQuery public function to add one or multiple \"data-validation\" argument.\n     *\n     * @param {string|array} validation Arguments to add in the node's data-validation\n     *\n     * @return {object} Modified DOM element\n     */\n    $.fn.addValidation = function (validation) {\n\n        return _api.addValidation(this, validation);\n\n    };\n\n    /**\n     * @public\n     * jQuery public function to remove one or multiple \"data-validation\" argument.\n     *\n     * @param {string|array} validation Arguments to remove in the node's data-validation\n     *\n     * @return {object} Modified DOM element\n     */\n    $.fn.removeValidation = function (validation) {\n\n        return _api.removeValidation(this, validation);\n\n    };\n\n    /**\n     * @public\n     * jQuery public function to add one or multiple errors.\n     *\n     * @param {object} error Object of errors where the keys are the input names\n     * @example\n     * $('form#myForm').addError({\n     *     'username': 'Invalid username, please choose another one.'\n     * });\n     *\n     * @return {object} Modified DOM element\n     */\n    $.fn.addError = function (error) {\n\n        return _api.addError(this, error);\n\n    };\n\n    /**\n     * @public\n     * jQuery public function to remove one or multiple errors.\n     *\n     * @param {array} error Array of errors where the keys are the input names\n     * @example\n     * $('form#myForm').removeError([\n     *     'username'\n     * ]);\n     *\n     * @return {object} Modified DOM element\n     */\n    $.fn.removeError = function (error) {\n\n        return _api.removeError(this, error);\n\n    };\n\n    /**\n     * @public\n     * jQuery public function to add a validation rule.\n     *\n     * @example\n     * $.alterValidationRules({\n     *     rule: 'FILENAME',\n     *     regex: /^[^\\\\/:\\*\\?<>\\|\\\"\\']*$/,\n     *     message: '$ has an invalid filename.'\n     * })\n     *\n     * @param {Object|Array} name\n     */\n    $.fn.alterValidationRules = $.alterValidationRules = function (rules) {\n\n        if (!(rules instanceof Array)) {\n            rules = [rules];\n        }\n\n        for (var i = 0; i < rules.length; i++) {\n            _api.alterValidationRules(rules[i]);\n        }\n\n    };\n\n    // =================================================================================================================\n\n    /**\n     * @private\n     * API to handles \"addValidation\" and \"removeValidation\" on attribute \"data-validation\".\n     * Note: Contains fail-safe operations to unify the validation parameter.\n     *\n     * @example\n     * $.addValidation('NOTEMPTY, L>=6')\n     * $.addValidation('[notempty, v>=6]')\n     * $.removeValidation(['OPTIONAL', 'V>=6'])\n     *\n     * @returns {object} Updated DOM object\n     */\n    var _api = {\n\n        /**\n         * @private\n         * This function unifies the data through the validation process.\n         * String, Uppercase and spaceless.\n         *\n         * @param {string|array} validation\n         *\n         * @returns {string}\n         */\n        _formatValidation: function (validation) {\n\n            validation = validation.toString().replace(/\\s/g, '');\n\n            if (validation.charAt(0) === \"[\" && validation.charAt(validation.length - 1) === \"]\") {\n                validation = validation.replace(/^\\[|]$/g, '');\n            }\n\n            return validation;\n\n        },\n\n        /**\n         * @private\n         * Splits the validation into an array, Uppercase the rules if they are not comparisons\n         *\n         * @param {String|Array} validation\n         *\n         * @returns {Array} Formatted validation keys\n         */\n        _splitValidation: function (validation) {\n\n            var validationArray = this._formatValidation(validation).split(','),\n                oneValidation;\n\n            for (var i = 0; i < validationArray.length; i++) {\n                oneValidation = validationArray[i];\n                if (/^[a-z]+$/i.test(oneValidation)) {\n                    validationArray[i] = oneValidation.toUpperCase();\n                }\n            }\n\n            return validationArray;\n        },\n\n        /**\n         * @private\n         * Joins the validation array to create the \"data-validation\" value\n         *\n         * @param {Array} validation\n         *\n         * @returns {String}\n         */\n        _joinValidation: function (validation) {\n\n            return '[' + validation.join(', ') + ']';\n\n        },\n\n        /**\n         * API method to attach the submit event type on the specified node.\n         * Note: Clears the previous event regardless to avoid double submits or unwanted behaviors.\n         *\n         * @param {Object} node jQuery object(s)\n         * @param {Object} options To configure the Validation class.\n         *\n         * @returns {*}\n         */\n        validate: function (node, options) {\n\n            if (typeof node === \"function\") {\n\n                if (!options.submit.settings.form) {\n\n                    // {debug}\n                    window.Debug.log({\n                        'node': node,\n                        'function': '$.validate()',\n                        'arguments': '',\n                        'message': 'Undefined property \"options.submit.settings.form - Validation dropped'\n                    });\n\n                    window.Debug.print();\n                    // {/debug}\n\n                    return;\n                }\n\n                node = $(options.submit.settings.form);\n\n                if (!node[0] || node[0].nodeName.toLowerCase() !== \"form\") {\n\n                    // {debug}\n                    window.Debug.log({\n                        'function': '$.validate()',\n                        'arguments': options.submit.settings.form,\n                        'message': 'Unable to find jQuery form element - Validation dropped'\n                    });\n\n                    window.Debug.print();\n                    // {/debug}\n\n                    return;\n                }\n\n            } else if (typeof node[0] === 'undefined') {\n\n                // {debug}\n                window.Debug.log({\n                    'node': node,\n                    'function': '$.validate()',\n                    'arguments': '$(\"' + node.selector + '\").validate()',\n                    'message': 'Unable to find jQuery form element - Validation dropped'\n                });\n\n                window.Debug.print();\n                // {/debug}\n\n                return;\n            }\n\n            if (options === \"destroy\") {\n\n                if (!window.Validation.form[node.selector]) {\n\n                    // {debug}\n                    window.Debug.log({\n                        'node': node,\n                        'function': '$.validate(\"destroy\")',\n                        'arguments': '',\n                        'message': 'Unable to destroy \"' + node.selector + '\", perhaps it\\'s already destroyed?'\n                    });\n\n                    window.Debug.print();\n                    // {/debug}\n\n                    return;\n                }\n\n                window.Validation.form[node.selector].destroy();\n\n                return;\n\n            }\n\n            return node.each(function () {\n                window.Validation.form[node.selector] = new Validation($(this), options);\n            });\n\n        },\n\n        /**\n         * API method to handle the addition of \"data-validation\" arguments.\n         * Note: ONLY the predefined validation arguments are allowed to be added\n         * inside the \"data-validation\" attribute (see configuration).\n         *\n         * @param {Object} node jQuery objects\n         * @param {String|Array} validation arguments to add in the node(s) \"data-validation\"\n         *\n         * @returns {*}\n         */\n        addValidation: function (node, validation) {\n\n            var self = this;\n\n            validation = self._splitValidation(validation);\n\n            if (!validation) {\n                return false;\n            }\n\n            return node.each(function () {\n\n                var $this = $(this),\n                    validationData = $this.attr(_data.validation),\n                    validationArray = (validationData && validationData.length) ? self._splitValidation(validationData) : [],\n                    oneValidation;\n\n                for (var i = 0; i < validation.length; i++) {\n\n                    oneValidation = self._formatValidation(validation[i]);\n\n                    if ($.inArray(oneValidation, validationArray) === -1) {\n                        validationArray.push(oneValidation);\n                    }\n                }\n\n                if (validationArray.length) {\n                    $this.attr(_data.validation, self._joinValidation(validationArray));\n                }\n\n            });\n\n        },\n\n        /**\n         * API method to handle the removal of \"data-validation\" arguments.\n         *\n         * @param {Object} node jQuery objects\n         * @param {String|Array} validation arguments to remove in the node(s) \"data-validation\"\n         *\n         * @returns {*}\n         */\n        removeValidation: function (node, validation) {\n\n            var self = this;\n\n            validation = self._splitValidation(validation);\n            if (!validation) {\n                return false;\n            }\n\n            return node.each(function () {\n\n                var $this = $(this),\n                    validationData = $this.attr(_data.validation),\n                    validationArray = (validationData && validationData.length) ? self._splitValidation(validationData) : [],\n                    oneValidation,\n                    validationIndex;\n\n                if (!validationArray.length) {\n                    $this.removeAttr(_data.validation);\n                    return true;\n                }\n\n                for (var i = 0; i < validation.length; i++) {\n                    oneValidation = self._formatValidation(validation[i]);\n                    validationIndex = $.inArray(oneValidation, validationArray);\n                    if (validationIndex !== -1) {\n                        validationArray.splice(validationIndex, 1);\n                    }\n\n                }\n\n                if (!validationArray.length) {\n                    $this.removeAttr(_data.validation);\n                    return true;\n                }\n\n                $this.attr(_data.validation, self._joinValidation(validationArray));\n\n            });\n\n        },\n\n        /**\n         * API method to manually trigger a form error.\n         * Note: The same form jQuery selector MUST be used to recuperate the Validation configuration.\n         *\n         * @example\n         * $('#form-signup_v3').addError({\n         *     'inputName': 'my error message',\n         *     'inputName2': [\n         *         'first error message',\n         *         'second error message'\n         *     ]\n         * })\n         *\n         * @param {Object} node jQuery object\n         * @param {Object} error Object of errors to add on the node\n         *\n         * @returns {*}\n         */\n        addError: function (node, error) {\n\n            if (!window.Validation.form[node.selector]) {\n\n                // {debug}\n                window.Debug.log({\n                    'node': node,\n                    'function': '$.addError()',\n                    'arguments': 'window.Validation.form[' + node.selector + ']',\n                    'message': 'ERROR - Invalid node selector'\n                });\n\n                window.Debug.print();\n                // {/debug}\n\n                return false;\n            }\n\n            if (typeof error !== \"object\" || Object.prototype.toString.call(error) !== \"[object Object]\") {\n\n                // {debug}\n                window.Debug.log({\n                    'node': node,\n                    'function': '$.addError()',\n                    'arguments': 'window.Validation.form[' + node.selector + ']',\n                    'message': 'ERROR - Invalid argument, must be type object'\n                });\n\n                window.Debug.print();\n                // {/debug}\n\n                return false;\n            }\n\n            var input,\n                onlyOnce = true;\n            for (var inputName in error) {\n\n                if (!error.hasOwnProperty(inputName)) {\n                    continue;\n                }\n\n                if (!(error[inputName] instanceof Array)) {\n                    error[inputName] = [error[inputName]];\n                }\n\n                input = $(node.selector).find('[name=\"' + inputName + '\"]');\n                if (!input[0]) {\n\n                    // {debug}\n                    window.Debug.log({\n                        'node': node,\n                        'function': '$.addError()',\n                        'arguments': inputName,\n                        'message': 'ERROR - Unable to find ' + '$(' + node.selector + ').find(\"[name=\"' + inputName + '\"]\")'\n                    });\n\n                    window.Debug.print();\n                    // {/debug}\n\n                    continue;\n                }\n\n                if (onlyOnce) {\n                    window.Validation.hasScrolled = false;\n                    onlyOnce = false;\n                }\n\n                window.Validation.form[node.selector].resetOneError(inputName, input);\n\n                for (var i = 0; i < error[inputName].length; i++) {\n\n                    if (typeof error[inputName][i] !== \"string\") {\n\n                        // {debug}\n                        window.Debug.log({\n                            'node': node,\n                            'function': '$.addError()',\n                            'arguments': error[inputName][i],\n                            'message': 'ERROR - Invalid error object property - Accepted format: {\"inputName\": \"errorString\"} or {\"inputName\": [\"errorString\", \"errorString\"]}'\n                        });\n\n                        window.Debug.print();\n                        // {/debug}\n\n                        continue;\n                    }\n\n                    window.Validation.form[node.selector].registerError(inputName, error[inputName][i]);\n\n                }\n\n                window.Validation.form[node.selector].displayOneError(inputName);\n\n            }\n\n        },\n\n        /**\n         * API method to manually remove a form error.\n         * Note: The same form jQuery selector MUST be used to recuperate the Validation configuration.\n         *\n         * @example\n         * $('#form-signin_v2').removeError([\n         *     'signin_v2[username]',\n         *     'signin_v2[password]'\n         * ])\n         *\n         * @param {Object} node jQuery object\n         * @param {Object} inputName Object of errors to remove on the node\n         *\n         * @returns {*}\n         */\n        removeError: function (node, inputName) {\n\n            if (!window.Validation.form[node.selector]) {\n\n                // {debug}\n                window.Debug.log({\n                    'node': node,\n                    'function': '$.removeError()',\n                    'arguments': 'window.Validation.form[' + node.selector + ']',\n                    'message': 'ERROR - Invalid node selector'\n                });\n\n                window.Debug.print();\n                // {/debug}\n\n                return false;\n            }\n\n            if (!inputName) {\n                window.Validation.form[node.selector].resetErrors();\n                return false;\n            }\n\n            if (typeof inputName === \"object\" && Object.prototype.toString.call(inputName) !== \"[object Array]\") {\n\n                // {debug}\n                window.Debug.log({\n                    'node': node,\n                    'function': '$.removeError()',\n                    'arguments': inputName,\n                    'message': 'ERROR - Invalid inputName, must be type String or Array'\n                });\n\n                window.Debug.print();\n                // {/debug}\n\n                return false;\n            }\n\n            if (!(inputName instanceof Array)) {\n                inputName = [inputName];\n            }\n\n            var input;\n            for (var i = 0; i < inputName.length; i++) {\n\n                input = $(node.selector).find('[name=\"' + inputName[i] + '\"]');\n                if (!input[0]) {\n\n                    // {debug}\n                    window.Debug.log({\n                        'node': node,\n                        'function': '$.removeError()',\n                        'arguments': inputName[i],\n                        'message': 'ERROR - Unable to find ' + '$(' + node.selector + ').find(\"[name=\"' + inputName[i] + '\"]\")'\n                    });\n\n                    window.Debug.print();\n                    // {/debug}\n\n                    continue;\n                }\n\n                window.Validation.form[node.selector].resetOneError(inputName[i], input);\n\n            }\n\n        },\n\n        /**\n         * API method to add a validation rule.\n         *\n         * @example\n         * $.alterValidationRules({\n         *     rule: 'FILENAME',\n         *     regex: /^[^\\\\/:\\*\\?<>\\|\\\"\\']*$/,\n         *     message: '$ has an invalid filename.'\n         * })\n         *\n         * @param {Object} ruleObj\n         */\n        alterValidationRules: function (ruleObj) {\n\n            if (!ruleObj.rule || (!ruleObj.regex && !ruleObj.message)) {\n                // {debug}\n                window.Debug.log({\n                    'function': '$.alterValidationRules()',\n                    'message': 'ERROR - Missing one or multiple parameter(s) {rule, regex, message}'\n                });\n                window.Debug.print();\n                // {/debug}\n                return false;\n            }\n\n            ruleObj.rule = ruleObj.rule.toUpperCase();\n\n            if (ruleObj.regex) {\n\n                var regex = _buildRegexFromString(ruleObj.regex);\n\n                if (!(regex instanceof RegExp)) {\n                    // {debug}\n                    window.Debug.log({\n                        'function': '$.alterValidationRules(rule)',\n                        'arguments': regex.toString(),\n                        'message': 'ERROR - Invalid rule'\n                    });\n                    window.Debug.print();\n                    // {/debug}\n                    return false;\n                }\n\n                _rules[ruleObj.rule] = regex;\n            }\n\n            if (ruleObj.message) {\n                _messages[ruleObj.rule] = ruleObj.message;\n            }\n\n            return true;\n        }\n\n    };\n\n    /**\n     * @private\n     * Converts string into a regex\n     *\n     * @param {String|Object} regex\n     * @returns {Object|Boolean} rule\n     */\n    function _buildRegexFromString(regex) {\n\n        if (!regex || (typeof regex !== \"string\" && !(regex instanceof RegExp))) {\n            _regexDebug();\n            return false;\n        }\n\n        if (typeof regex !== 'string') {\n            regex = regex.toString();\n        }\n\n        var separator = regex.charAt(0),\n            index = regex.length - 1,\n            pattern,\n            modifier,\n            rule;\n\n        while (index > 0) {\n            if (/[gimsxeU]/.test(regex.charAt(index))) {\n                index--;\n            } else {\n                break;\n            }\n        }\n\n        if (regex.charAt(index) !== separator) {\n            separator = null;\n        }\n\n        if (separator && index !== regex.length - 1) {\n            modifier = regex.substr(index + 1, regex.length - 1);\n        }\n\n        if (separator) {\n            pattern = regex.substr(1, index - 1);\n        } else {\n            pattern = regex;\n        }\n\n        try {\n            rule = new RegExp(pattern, modifier);\n        } catch (error) {\n            _regexDebug();\n            return false;\n        }\n\n        return rule;\n\n        function _regexDebug() {\n            // {debug}\n            window.Debug.log({\n                'function': '_buildRegexFromString()',\n                'arguments': '{pattern: {' + (pattern || '') + '}, modifier: {' + (modifier || '') + '}',\n                'message': 'WARNING - Invalid regex given: ' + regex\n            });\n            window.Debug.print();\n            // {/debug}\n        }\n\n    }\n\n    // {debug}\n    window.Debug = {\n\n        table: {},\n        log: function (debugObject) {\n\n            if (!debugObject.message || typeof debugObject.message !== \"string\") {\n                return false;\n            }\n\n            this.table[debugObject.message] = $.extend(\n                Object.preventExtensions(\n                    {\n                        'node': '',\n                        'function': '',\n                        'arguments': ''\n                    }\n                ), debugObject\n            );\n\n        },\n        print: function () {\n\n            if ($.isEmptyObject(this.table)) {\n                return false;\n            }\n\n            if (console.group !== undefined || console.table !== undefined) {\n\n                console.groupCollapsed('--- jQuery Form Validation Debug ---');\n\n                if (console.table) {\n                    console.table(this.table);\n                } else {\n                    $.each(this.table, function (index, data) {\n                        console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');\n                    });\n                }\n\n                console.groupEnd();\n\n            } else {\n                console.log('Debug is not available on your current browser, try the most recent version of Chrome or Firefox.');\n            }\n\n            this.table = {};\n\n        }\n\n    };\n    // {/debug}\n\n    String.prototype.capitalize = function () {\n        return this.charAt(0).toUpperCase() + this.slice(1);\n    };\n\n    if (!Array.prototype.indexOf) {\n        Array.prototype.indexOf = function (elt /*, from*/) {\n            var len = this.length >>> 0;\n\n            var from = Number(arguments[1]) || 0;\n            from = (from < 0)\n                ? Math.ceil(from)\n                : Math.floor(from);\n            if (from < 0)\n                from += len;\n\n            for (; from < len; from++) {\n                if (from in this &&\n                    this[from] === elt)\n                    return from;\n            }\n            return -1;\n        };\n    }\n\n    // {debug}\n    if (!JSON && !JSON.stringify) {\n        JSON.stringify = function (obj) {\n            var t = typeof (obj);\n            if (t !== \"object\" || obj === null) {\n                // simple data type\n                if (t === \"string\") {\n                    obj = '\"' + obj + '\"';\n                }\n                return String(obj);\n            }\n            else {\n                var n, v, json = [], arr = (obj && obj.constructor === Array);\n                for (n in obj) {\n                    if (true) {\n                        v = obj[n];\n                        t = typeof(v);\n                        if (t === \"string\") {\n                            v = '\"' + v + '\"';\n                        }\n                        else if (t === \"object\" && v !== null) {\n                            v = JSON.stringify(v);\n                        }\n                        json.push((arr ? \"\" : '\"' + n + '\": ') + String(v));\n                    }\n                }\n                return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\");\n            }\n        };\n    }\n    // {/debug}\n\n}(window, document, window.jQuery));"
